# 知识总结：

## 一、JS

### 1、数据类型
    内置对象分为两大类型：基本类型和引用类型
    基本类型：string，number，symbol（es6新增），boolean，null，undefined，其中js的数字类型是浮点类型的，
    没有整型，这是基于IEEE754的标准实现的。NaN也是属于number类型的，并且NaN不等于其自身。对于基本类型来说，
    如果使用字面量的方式，那么这个变量只是个字面量，只在必要的时候才会转成对应的类型
        let a = 111  // 这只是字面量，不是 number 类型  
		    a.toString() // 使用时候才会转换为对象类型  
    基本类型的特点：值是不可以改变的、比较的都是值得比较、数据存放在栈区

    引用类型：object（对象，数组，函数等），对象是引用类型，在使用的过程中要注意深拷贝和浅拷贝的问题
    引用类型的特点：值是可以改变的，拥有属性和方法、都是引用的比较、同时存放在栈内存和堆内存的对象

    两种类型区别：
       存储位置不同：基本类型只存放在stack中、引用类型同时存放在heap和stack中
       访问的方式不同：基本类型是值访问，引用类型是引用访问

    深拷贝和浅拷贝只是针对Object和Array这样的引用数据类型的。浅拷贝只是复制指向某个对象的指针，而不复制对象本身，
    新旧对象还是共享同一块内存。但是深拷贝会另外创造一个一模一样的对象，新对象和原对象不共享内存，修改新对象不会影响原对象。

    ***浅拷贝的实现方式：
       1、Object.assign();
       2、Array.prototype.concat();
       3、Array.prototype.slice();
     
    ***深拷贝的实现方式：
       1、JSON.parse(JSON.stringify());
       2、手写递归算法
          //定义检测数据类型的功能函数
          function checkedType(target) {
            return Object.prototype.toString.call(target).slice(8, -1)
          }
          //实现深度克隆---对象/数组
          function clone(target) {
            //判断拷贝的数据类型
            //初始化变量result 成为最终克隆的数据
            let result,
              targetType = checkedType(target)
            if (targetType === 'Object') {
              result = {}
            } else if (targetType === 'Array') {
              result = []
            } else {
              return target
            }
            //遍历目标数据
            for (let i in target) {
              //获取遍历数据结构的每一项值。
              let value = target[i]
              //判断目标结构里的每一值是否存在对象/数组
              if (checkedType(value) === 'Object' || checkedType(value) === 'Array'){
                //对象/数组里嵌套了对象/数组
                //继续遍历获取到value值
                result[i] = clone(value)
              } else {
                //获取到value值是基本的数据类型或者是函数。
                result[i] = value
              }
            }
            return result
          } 
       3、函数库lodash  

### 2、检测数据类型
     typeof对于基本类型是有效的，但是对于null会将其判断成object（JS最初的时候，使用的是32位的操作系统，
     为了性能考虑使用低位存储变量的类型信息，000开头表示对象，然而null则是全为0。虽然现在的内部类型判断代码已经改变，
     但是这个Bug却是一直流传下来了） typeof判断对象为object，能检测数组和对象，但是函数会显示成function

     instanceof的内部机制是通过判断原型链是否能够占到类型的prototype
     但是不能检测字面量方式创建的基本数据类型、不能检测null和undefined、在类的原型链中检测未必准确
  		function instanceof(left, right) {
  		    // 获得类型的原型
  		    let prototype = right.prototype
  		    // 获得对象的原型
  		    left = left.__proto__
  		    // 判断对象的类型是否等于类型的原型
  		    while (true) {
  		    	if (left === null)
  		    		return false
  		    	if (prototype === left)
  		    		return true
  		    	left = left.__proto__
  		    }
  		}

     严格运算符（===）：只能判断null和undefined

     constructor：不能检测null和undefined、把类的原型进行重写，检测的不准确

     Object.prototype.toString.call()：最准确最常用的方式
     
### 3、类型转换
     Boolean：在条件判断时候，除了undefined、null、false、NaN、''、0、-0，其他所有的值都是true，包括所有对象

     对象转成基本类型: valueOf、toString、Symbol.toPrimitive(优先级最高)
      let a = {
  		  valueOf() {
  		    return 0;
  		  },
  		  toString() {
  		    return '1';
  		  },
  		  // 优先级最高,没有这个的话，使用的是valueOf，下面的结果是1和10，最后是使用toString,结果是 11和11
  		  [Symbol.toPrimitive]() {
  		    return 2;
  		  }
	    }
	    结果：
	    1 + a // => 3
	    '1' + a // => '12'

	   四则运算符：在加法运算的时候，如果一方是string类型，也会把另一方转成string。在其他算的时候如果有一方是number，
     自另一方也会是number。加法运算中会触发三种类型转换：将值转成原始值，转换为数字，转换成字符串
  		 1 + '1' // '11'
  		 2 * '2' // 4
  		 [1, 2] + [2, 1] // '1,22,1'
  		 // [1, 2].toString() -> '1,2'
  		 // [2, 1].toString() -> '2,1'
  		 // '1,2' + '2,1' = '1,22,1'

    	 对于加号需要注意这个表达式 'a' + + 'b'
    	 'a' + + 'b' // -> "aNaN"
    	 // 因为 + 'b' -> NaN
    	 // 你也许在一些代码中看到过 + '1' -> 1

	   比较运算符：如果是对象，就通过toPrimitive转换对象、日过是字符串，就通过Unicode字符索引来比较

### 4、原型（浅深拷贝，继承等）

     构造函数：constructor 返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串

     prototype：这是一个显式原型属性，只有函数才会拥有该属性。但是有一个函数例外:Function.prototype.bind()，
     用他创建的函数并不具有prototype属性。prototype在创建的时候自动创建了，该属性的值是一个对象，
     只有一个属性是constructor，对应是构造函数，一旦修改函数的prototype，那么新对象就没有这个属性
     （当然也可以通过原型链取到constructor）。在大部分的情况下是没有用的，在我的理解中，
     主要有两个方面的作用：让实例知道是什么函数构造了他、如果想给某些类库中的构造函数添加一些自定义方法，
     可以通过XX.constructor.method来扩展。

     __proto__：这是没有对象拥有的隐式原型属性，指向了创建该对象的构造喊出的原型。其实这个属性指向了[[prototype]]，
     但是这个是内部属性，我们并不能访问到，所以使用__proto__来访问，现在也可以使用getPrototypeOf来访问。
     因为在js中没有类的概念，所以通过__proto__将对象和原型联系起来组成了原型链。
     可以使对象可以访问到不属于自己的属性。__proto__是通过new操作符产生的。

     new的过程：生成新的对象，获取构造函数，链接到原型，绑定this并执行构造函数，返回新的对象
       function create() {
        	// 创建一个新的对象
        	let obj = new Object();
        	// 获取构造函数
        	let con = [].shift.call(arguments);
        	// 链接到原型
        	obj.__proto__ = con.prototype;
        	// 绑定到this，执行构造函数
        	let result  = con.apply(obj, arguemnts);
        	// 确保new的结果是一个对象
        	return typeof result === 'object' ? result : obj;
       }

     对于实例对象来说，都是通过new产生的，无论是function还是字面量。对于一个对象来说，推荐使用字面量的方式来创建对象。
     因为使用new Object()的方式创建对象需要通过作用域链的方式查到Object，但是使用字面量的方式就没有这个问题。
      	function Foo() {}
    		// function 就是个语法糖
    		// 内部等同于 new Function()
    		let a = { b: 1 }
    		// 这个字面量内部也是使用了 new Object()
     对于 new 来说，还需要注意下运算符优先级。从下面可以看出，new Foo()的优先级是大于new Foo的
        function Foo() {
            return this;
        }
        Foo.getName = function () {
            console.log('1');
        };
        Foo.prototype.getName = function () {
            console.log('2');
        };

        new Foo.getName();   // -> 1
        new Foo().getName(); // -> 2  

        new (Foo.getName());  // 类似静态类
        (new Foo()).getName(); // 类似类的对象
     Function.proto === Function.prototype，所以可以这样说，所有实例都是对象，但是对象不一定都是实例

     总结：
      1、Object是所有对象的爸爸，所有对象都可以通过__proto__找到他
      2、Function是所有函数的父类，所有的函数都可以通过__proto__找到他
      3、Function.prototype和Object.prototype是两个特殊的对象，他们由引擎来创建
      4、处理上面两个特殊对象，其他对象都是通过构造器new出来的
      5、函数的prototype是一个对象，也就是原型
      7、对象的__proto__指向原型，__proto__将对象和原型连接起来组成了原型链

     ***继承
      1、原型继承
       子类型的原型是父类型的一个实例对象
           //父类型
           function Person(name, age) {
             this.name = name,
             this.age = age,
             this.play = [1, 2, 3]
             this.setName = function () {}
           }
           Person.prototype.setAge = function () {}
           //子类型
           function Student(price) {
             this.price = price
             this.setScore = function () {}
           }
           Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象
           var s1 = new Student(15000)
           var s2 = new Student(14000)
           console.log(s1,s2);
        但这种方式实现的本质是通过将子类的原型指向了父类的实例，所以子类的实例就可以通过__proto__访问到
         Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto__
         指向父类的prototype就可以获得到父类原型上的方法。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性

        子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法，
        我们都知道在操作基本数据类型的时候操作的是值，在操作引用数据类型的时候操作的是地址，
        如果说父类的私有属性中有引用类型的属性，那它被子类继承的时候会作为公有属性，
        这样子类1操作这个属性的时候，就会影响到子类2。   

        特点：
          父类新增原型方法/原型属性，子类都能访问到
          简单，易于实现
        缺点：
          无法实现多继承
          来自原型对象的所有属性被所有实例共享
          创建子类实例时，无法向父类构造函数传参
          要想为子类新增属性和方法，必须要在Student.prototype = new Person() 之后执行，不能放到构造器中
      2、构造函数继承
        在子类型构造函数中通用call调用父类型构造函数
          function Person(name, age) {
            this.name = name,
            this.age = age,
            this.setName = function () {}
          }
          Person.prototype.setAge = function () {}
          function Student(name, age, price) {
            Person.call(this, name, age)  // 相当于: this.Person(name, age)
            /*this.name = name
            this.age = age*/
            this.price = price
          }
          var s1 = new Student('Tom', 20, 15000)
        特点：
          解决了原型链继承中子类实例共享父类引用属性的问题
          创建子类实例时，可以向父类传递参数
          可以实现多继承(call多个父类对象)

        缺点：
          实例并不是父类的实例，只是子类的实例
          只能继承父类的实例属性和方法，不能继承原型属性和方法
          无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
      3、原型链+借用构造函数的组合继承
        这种方式关键在于：通过调用父类构造，继承父类的属性并保留传参的有点，然后通过将父类实例作为子类原型，实现函数复用。
          function Person (name, age) {
            this.name = name,
            this.age = age,
            this.setAge = function () { }
          }
          Person.prototype.setAge = function () {
            console.log("111")
          }
          function Student (name, age, price) {
            Person.call(this, name, age)
            this.price = price
            this.setScore = function () { }
          }
          Student.prototype = new Person()
          Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的
          Student.prototype.sayHello = function () { }
          var s1 = new Student('Tom', 20, 15000)
          var s2 = new Student('Jack', 22, 14000)
          console.log(s1)
          console.log(s1.constructor) //Student
          console.log(p1.constructor) //Person  
        这种方式融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。不过也存在缺点就是无论在
        什么情况下，都会调用两次构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数的内部，
        子类型最终会包含父类型对象的全部实例属性，但我们不得不在调用子类构造函数时重写这些属性。
        优点：
          可以继承实例属性/方法，也可以继承原型属性/方法
          不存在引用属性共享问题
          可传参
          函数可复用
        缺点：
          调用了两次父类构造函数，生成了两份实例 
      4、组合继承优化1
        这种方式通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，
        而且不会初始化两次实例方法/属性，避免的组合继承的缺点。
          function Person (name, age) {
            this.name = name,
            this.age = age,
            this.setAge = function () { }
          }
          Person.prototype.setAge = function () {
            console.log("111")
          }
          function Student (name, age, price) {
            Person.call(this, name, age)
            this.price = price
            this.setScore = function () { }
          }
          Student.prototype = Person.prototype
          Student.prototype.sayHello = function () { }
          var s1 = new Student('Tom', 20, 15000)
          console.log(s1)       
        优点：
          不会初始化两次实例方法/属性，避免的组合继承的缺点
        缺点：
          没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。
      5、组合继承优化2
        借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，
        生成了B对象。B继承了A的所有属性和方法。
          function Person (name, age) {
            this.name = name,
            this.age = age
          }
          Person.prototype.setAge = function () {
            console.log("111")
          }
          function Student (name, age, price) {
            Person.call(this, name, age)
            this.price = price
            this.setScore = function () { }
          }
          Student.prototype = Object.create(Person.prototype)//核心代码
          Student.prototype.constructor = Student//核心代码
          var s1 = new Student('Tom', 20, 15000)
          console.log(s1 instanceof Student, s1 instanceof Person) // true true
          console.log(s1.constructor) //Student
          console.log(s1)  
      6、ES6中class 的继承
        ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类
        的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。ES5 的继承，实质是先创造子类
        的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，
        实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。
        需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。
          class Person {
            //调用类的构造方法
            constructor(name, age) {
              this.name = name
              this.age = age
            }
            //定义一般的方法
            showName () {
              console.log("调用父类的方法")
              console.log(this.name, this.age);
            }
          }
          let p1 = new Person('kobe', 39)
          console.log(p1)
          //定义一个子类
          class Student extends Person {
            constructor(name, age, salary) {
              super(name, age)//通过super调用父类的构造方法
              this.salary = salary
            }
            showName () {//在子类自身定义方法
              console.log("调用子类的方法")
              console.log(this.name, this.age, this.salary);
            }
          }
          let s1 = new Student('wade', 38, 1000000000)
          console.log(s1)
          s1.showName();
        优点：
          语法简单易懂,操作更方便
        缺点：
          并不是所有的浏览器都支持class关键字

        继承要实现的：能传递参数、多个实例不能持有对引用类型的篡改、不会产生多余的父类方法多余开销

### 5、this
     了解this：
       this既不指向函数自身也不指向函数的词法作用域
       JS中的this代表的是当前行为执行的主体
       this实际上实在函数被调用时发生的绑定
       他指向什么完全取决于函数在哪里被调用

     this到底是谁
       函数执行时候首先看函数名前面是否有"." (有的话就是前面的，没有的话就是window)
          function fn(){
            console.log(this);
          }
          var obj={fn:fn};
          fn();//  this -> window
          obj.fn();//this -> obj
          function sum(){
               fn();// this -> window
          }
          sum();
          var oo = {
           sum:function() {
               console.log(this);// this -> oo
                 fn()；// this-> window
            }
          };
          oo.sum();

       自执行函数中的this永远是window
          (function(){ //this->window })();

       给元素的某一个事件绑定方法，方法中的this是当前的元素(在IE6~8下使用attachEvent，
       默认的this就是指的window对象)
          function fn(){
            console.log(this);
          } 
          document.getElementById("div1").onclick=fn; // fn中的this就是#divl
          document.getElementById("div1").onclick=function(){
          console.log(this);// this->#div1
          fn(); // this->window

       在构造函数模式中，this.XXX = XXX中的this是当前类的一个实例。类中某一个属性值(方法)，
       方法中的this需要看方法执行的时候，前面是否有".",才能知道this是谁。
            function Fn(){
              this.x=100；// this -> f1
              this.getX = function() {
                  console.log(this.x);//this->需要看getX执行的时候才知道
              }
            }
            var f1=new Fn;
            f1.getX();// -> 方法中的this是f1，所以f1.x=100
            var ss = f1.getX;
            ss(); //->方法中的this是window ->undefined，隐式绑定有的时候会丢失

       call、apply和bind
          apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法执行，而且在严格模式下
          和非严格模式下对于第一个参数是null/undefined这种情况的规律也是一样的。 两者唯一的区别：
          call在给fn传递参数的时候，是一个个的传递值的，而apply不是一个个传，而是把要给fn传递的参数值
          统一的放在一个数组中进行操作。但是也相当子一个个的给fn的形参赋值。总结一句话:call第二个参数
          开始接受一个参数列表,apply第二个参数开始接受一个参数数组
              //在非严格模式下
              var obj={name:"浪里行舟 "};
              function fn(num1,num2){
                console.log(num1+num2);
                console.log(this);
              }
              fn.call(100,200);//this->100 num1=200 num2=undefined
              fn.call(obj,100,200);//this->obj num1=100 num2=200
              fn.call();//this->window
              fn.call(null);//this->window
              fn.call(undefined);//this->window

              //严格模式下 
              fn.call();//在严格模式下this->undefined
              fn.call(null);// 在严格模式 下this->null
              fn.call(undefined);//在严格模式下this->undefined
          bind体现了预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，
          以后要用到了，直接的执行即可。call和apply直接执行函数，而bind需要再一次调用。
              var a ={
                    name : "Cherry",
                    fn : function (a,b) {
                        console.log( a + b)
                    }
                }
              var b = a.fn;
              b.bind(a,1,2); // 没有执行函数
              b.bind(a,1,2)() // 3
          // 自定义实现call     
          Function.prototype.myCall = function (context) {
            var context = context || window
            // 给 context 添加一个属性
            // getValue.call(a, 'yck', '24') => a.fn = getValue
            context.fn = this
            // 将 context 后面的参数取出来
            var args = [...arguments].slice(1)
            // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
            var result = context.fn(...args)
            // 删除 fn
            delete context.fn
            return result
          }
          // 自定义实现apply
          Function.prototype.myApply = function (context) {
            var context = context || window
            context.fn = this

            var result
            // 需要判断是否存储第二个参数
            // 如果存在，就将第二个参数展开
            if (arguments[1]) {
              result = context.fn(...arguments[1])
            } else {
              result = context.fn()
            }

            delete context.fn
            return result
          }
          // 自定义实现bind(利用了闭包的概念)
          Function.prototype.myBind = function (context) {
            if (typeof this !== 'function') {
              throw new TypeError('Error')
            }
            var _this = this;
            var args = [...arguments].slice(1);
            // 返回一个函数
            return function F() {
              // 因为返回了一个函数，我们可以 new F()，所以需要判断
              if (this instanceof F) {
                return new _this(...args, ...arguments)
              }
              return _this.apply(context, args.concat(...arguments))
            }
          }

     箭头函数this指向：更简短的函数并且不绑定this，定义的时候处在的对象就是他的this。
     换句话说，箭头函数的this看外层的是否有函数。如果有，外层
        函数的this就是内部箭头函数的this，如果没有，则this就是window。使用call、apply无法对this进行绑定。
        var obj = {
            birth: 1990,
            getAge: function (year) {
                var b = this.birth; // 1990
                var fn = (y) => y - this.birth; // this.birth仍是1990
                return fn.call({birth:2000}, year);
            }
        };
        obj.getAge(2018); // 28
     
     this的优先级顺序
        显式绑定 > 隐式绑定 > 默认绑定
        new绑定 > 隐式绑定 > 默认绑定
        显示绑定和new绑定不存在同时存在于同一个场景下面，有的话页面就会报错了
     
     总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中

### 6、作用域
     scope：是在运行时代码中某些特定部分中变量，函数和对象的可访问性。换句话说，作用于决定了代码区块中
     变量和其他资源的可见性。最大的最庸是隔离变量，防止冲突。在ES6之前没有块级作用域（可以通过let和const来体现）
     ，只有全局作用域和函数作用域。
       1、全局作用域：最外层的函数和在最外层函数中定义的变量、未定义直接赋值的变量、所有的window对象。
       2、函数作用域：是指声明在函数内部的变量。
       3、块级作用域：可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。创建的情况，
          在一个函数内部、在一个代码块（由一对花括号包裹）内部。主要的特点： 声明变量不会提升到代码块顶部、
          禁止重复声明、循环中的绑定块作用域的妙用
       作用域是分层的，内层作用域可以访问外层作用域中的变量，反之则不行。
     
     作用域链
      自由变量：当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找
      作用域链：如果变量在自身和父级作用域中都没有，再一层一层向上寻找，直到找到全局作用域找到或者没有找到，
               这种一层一层的关系，就是作用域链 。
        var a = 100
        function F1() {
            var b = 200
            function F2() {
                var c = 300
                console.log(a) // 自由变量，顺作用域链向父作用域找
                console.log(b) // 自由变量，顺作用域链向父作用域找
                console.log(c) // 本作用域的变量
            }
            F2()
        }
        F1()  

       作用域与执行上下文
        js是属于解释型的语言，js的执行分为：解释和执行两个阶段，这两个阶段所做的事情并不一样。
        解释阶段：词法分析、语法分析、作用域规则确定
        执行阶段：创建执行上下文、执行函数代码、垃圾回收
        js的解释阶段就会确认作用域规则，因此作用域在函数定义的时候就已经确认了，而不是在函数调用的时候确认，
        但是执行上下文是函数执行之前创建的。执行上下文最明显的及时this的指向是执行时确认的。
        而作用域访问的变量是编写代码的结构确认的。作用域和执行上下文之间最大的区别是：执行上下文在运行时确认的，
        随时可能改变；随时可能改变；作用域在定义时就确认，并不会改变。一个作用域下面可能包含了若干个上下文环境。
        有可能从来没有没有过上下文环境（函数从未被调用过）；有可能有过，现在函数被调用完毕之后，上下文环境被销毁了；
        有可能同时存在一个或者是多个（闭包）。在同一个作用域下面，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。

### 7、执行上下文
     执行上下文就是当前的js的代码被解析和执行时所在环境的抽象概念，js中运行任何的代码都是在执行上下文中运行的

     执行上下文的类型：
      1、全局执行上下文：默认的最基础执行上下文，函数中的代码不会存在于此。主要做两件事情：创建一个全局对象，
         在浏览器中的全局对象就是window对象、将this指针指向这个全局对象。一个程序中只会有一个全局执行上下文。
      2、函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每一个函数都拥有自己执行上下文，
         但是只有在调用的时候才会被创建。一盒程序中可以存在任意数目的函数执行上下文。每当一个新的执行上下文被创建，
         他都会按照特定的顺序执行一系列步骤。
      3、Eval函数执行上下文：运行在本函数中的代也会获得自己的执行上下文

     执行栈：
      执行栈，也叫调用栈，具有LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。首先运行JS代码时，
      会创建一个全局执行上下文并push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文
      并push到当前执行栈的栈顶。根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中pop
      出，上下文控制权将当前执行栈的下一个执行上下文

     执行上下文的生命周期：
      1、创建阶段：创建变量对象、创建作用域链、确定this的指向
      2、执行阶段：执行变量赋值，代码执行
      3、回收阶段：执行上下文出栈后等待虚拟机回收执行上下文

     执行上下文的创建：
      执行上下文分为两个阶段创建：1、创建阶段 2、执行阶段

     执行上下文阶段（创建阶段）：
        ExecutionContext = {  
            // 确定this的值
            ThisBinding = <this value>,
            // 创建词法环境
            LexicalEnvironment = {},
            // 创建变量环境
            VariableEnvironment = {},
        };
      1、确定this
        全局执行上下文中，this的值指向全局对象，在浏览器中的this的指向window对象，而在nodejs中指向这个文件的
        module对象
        函数执行上下文中，this的值取决于函数的调用方式。默认绑定、隐式绑定、显式绑定、new绑定、箭头函数绑定
      2、词法环境
        词法环境有两个组成部分：
          1、环境记录：存储变量和函数声明的实际位置
          2、对外部环境的引用：可以访问其外部词法环境
        词法环境有两种类型：
          1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为null。拥有一个全局对象（window对象）及其
            关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this的值指向这个全局对象
          2、函数变量：用户在函数中定义的变量被存储在环境记录中，包含了arguments对象。对外部环境的引用可以是
            全局环境，也可以是包含内部函数的外部函数环境
      3、变量环境
        变量环境也是一个词法环境。在ES6中唯一的区别就是用于存储函数声明与let、const声明的变量，而变量环境仅仅
        存储var声明的变量
    
     变量提升和this的指向细节
      变量提升、函数提升、函数 > 变量提升
      1、变量声明提升：大部分的编程语言都是先声明在使用，在js中可能与此相反都能运行，但是在严格模式模式下会有问题

      2、函数声明提升：
            console.log(f1) // function f1(){}
            function f1() {} // 函数声明
            console.log(f2) // undefined
            var f2 = function() {} // 函数表达式
         有个细节必须注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，
         但是可以重新赋值。还有这事因为当函数执行的时候，首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：
         如果有形参，先给形参赋值；进行私有作用域中预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，
         但是可以重新赋值；私有作用域中的代码从上到下执行

      3、确定this的指向
        确定一个概念---this的值是在执行的时候才能确认，定义的时候不能确认。因为this是执行上下文环境的一部分，
        而执行上下文需要在代码执行之前确定，而不是在定义的时候确认
            // 情况1
            function foo() {
              console.log(this.a) //1
            }
            var a = 1
            foo()

            // 情况2
            function fn(){
              console.log(this);
            }
            var obj = { fn:fn };
            obj.fn(); // this -> obj

            // 情况3
            function CreateJsPerson(name,age){
              //this是当前类的一个实例p1
              this.name=name; //=>p1.name=name
              this.age=age; //=>p1.age=age
            }
            var p1 = new CreateJsPerson("尹华芝",48);

            // 情况4
            function add(c, d){
              return this.a + this.b + c + d;
            }
            var o = {a:1, b:3};
            add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
            add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34

            // 情况5
            <button id="btn1">箭头函数this</button>
            <script type="text/javascript">   
                let btn1 = document.getElementById('btn1');
                let obj = {
                    name: 'kobe',
                    age: 39,
                    getName: function () {
                        btn1.onclick = () => {
                            console.log(this);//obj
                        };
                    }
                };
                obj.getName();
            </script>
            1、对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window
            2、对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下
               foo 函数中的 this 就是 obj 对象
            3、在构造函数模式中，类中(函数体中)出现的 this.xxx = xxx 中的this是当前类的一个实例
            4、call、apply和bind：this 是第一个参数
            5、箭头函数this指向：箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this
               就是内部箭头函数的this，如果没有，则this是window

      执行上下文栈
        函数多了，就会有多个函数执行上下文，每次调用函数就会创建一个新的执行上下文，js引擎创建了执行上下文栈来管理执行上下文。
        可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。
        记住以下的关键点：
         1、js执行在单线程上，所有的代码都是排队进行的
         2、一开始浏览器执行全局的代码时候，首先创建全局的执行上下文，压入执行栈的顶部
         3、每当进入一个函数的执行就会创建函数的执行上下文，并且把他压入执行栈的顶部。当前函数执行完成后，
            当前函数的执行上下文出栈，并且等待垃圾回收
         4、浏览器的js执行引擎总是访问站定的执行上下文
         5、全局上下文只有唯一的一个，他在浏览器关闭的时候出栈
         6、执行上下文创建阶段分为绑定this，创建词法环境，变量环境三步，两者区别在于词法环境存放函数声明与const、let声明的变量，
             而变量环境只存储var声明的变量；你应该明白了为什么会存在变量提升，函数提升，而let、const没有；

### 8、闭包
     闭包是js中的一个难点，有他自己的特色，很多高级应用都要依靠闭包实现。最大的特点：可以记住诞生的环境，
     比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
     当函数可以记住并访问所在的词法作用域，即使函数是当前词法作用域之外执行，这就产生了闭包。
     形成的条件

      1、函数嵌套
      2、内部函数引用外部函数的局部变量
     闭包的特性
      1、每一个函数天生都很够记忆自己定义时候的所处的作用域环境
      2、不管函数走到哪里，定义的时候的作用域就会带到哪里
        //例题1
        var inner;
        function outer() {
          var a=250;
          inner = function() {
            alert(a);//这个函数虽然在外面执行，但能够记忆住定义时的那个作用域，a是250
          }
        }
        outer();
        var a = 300;
        inner();//一个函数在执行的时候，找闭包里面的变量，不会理会当前作用域。
     闭包的内存泄漏
      1、延长外部函数局部变量的生命周期
        一般情况下，函数执行会形成一盒新的私有的作用域，当私有作用域中的代码执行完成之后，我们当前作用域都会主动的进行释放和销毁。
        但是当遇到函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西接收了，这种情况下面的形成的私有作用域都不会被销毁。
        闭包不能滥用，否则会导致内存泄漏，影响网页的性能。闭包使用完成之后，要立即释放资源，将引用变量指向null。
        function fn(){
          var num=100;
          return function(){}
        }
        var f=fn();//fn执行形成的这个私有的作用域就不能再销毁了
     闭包的作用：
      1、可以访问函数内部的变量
      2、使变量的值长期保存在内存中
      3、可以用来实现js模块
         具有特定功能的js文件
         将所有的数据和功能封装在一个函数的内部(私有的)
         只向外面暴露一个包信n个方法的对象或函数
        //index.html文件
        <script type="text/javascript" src="myModule.js"></script>
        <script type="text/javascript">
          myModule2.doSomething()
          myModule2.doOtherthing()
        </script>

        //myModule.js文件
        (function () {
          var msg = 'Beijing'//私有数据
          //操作数据的函数
          function doSomething() {
            console.log('doSomething() '+msg.toUpperCase())
          }
          function doOtherthing () {
            console.log('doOtherthing() '+msg.toLowerCase())
          }
          //向外暴露对象(给外部使用的两个方法)
          window.myModule2 = {
            doSomething: doSomething,
            doOtherthing: doOtherthing
          }
        })()
     闭包的运用
      1、点击摸一个按钮，提示点击的是第几个按钮
          <button>测试1</button>
          <button>测试2</button>
          <button>测试3</button>
          <script type="text/javascript">
             var btns = document.getElementsByTagName('button')
              for (var i = 0; i < btns.length; i++) {
                btns[i].onclick = function () {
                  console.log('第' + (i + 1) + '个')
                }
              }
          </script>  
      防抖（或者是节流）
        // func是用户传入需要防抖的函数
        // wait是等待时间
        const debounce = (func, wait = 50) => {
          // 缓存一个定时器id
          let timer = 0
          // 这里返回的函数是每次用户实际调用的防抖函数
          // 如果已经设定过定时器了就清空上一次的定时器
          // 开始一个新的定时器，延迟执行用户传入的方法
          return function(...args) {
            if (timer) clearTimeout(timer)
            timer = setTimeout(() => {
              func.apply(this, args)
            }, wait)
          }
        }

### 9、异步

      1、Promise的原理与基本语法
        异步编程模式在前端开发过程中，显得越来越重要。从最开始的XHR到封装后的Ajax都在试图解决异步编程过程中的问题。随着ES6新标准的到来，
        处理异步数据流又有了新的方案。我们都知道，在传统的ajax请求中，当异步请求之间的数据存在依赖关系的时候，就可能产生很难看的多层回调，
        俗称'回调地狱'（callback hell），这却让人望而生畏，Promise的出现让我们告别回调函数，写出更优雅的异步代码。在实践过程中，
        却发现Promise并不完美，Async/Await是近年来JavaScript添加的最革命性的的特性之一，Async/Await是近年来
        JavaScript添加的最革命性的的特性之一，Asyncit提供了一种使得异步代码看起来像同步代码的替代方法。接下来我们介绍这两种处理异步编程的方案。
        1、Promise原理
          Promise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。主流的规范是 Promises/A+。
          Promise中有几个状态：

          pending: 初始状态, 非 fulfilled 或 rejected；
          fulfilled: 成功的操作，为表述方便，fulfilled 使用 resolved 代替；
          rejected: 失败的操作。

          pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。
          并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。
        2.Promise的基本语法
          Promise实例必须实现then这个方法
          then()必须可以接收两个函数作为参数
          then()返回的必须是一个Promise实例
      2、Promise多个串联操作
        Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。
        要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写job1.then(job2).then(job3).catch(handleError);
        其中job1、job2和job3都是Promise对象。
      3、Promise常用方法
        除了串行执行若干异步任务外，Promise还可以并行执行异步任务。
        Promise.all接受一个promise对象的数组，待全部完成之后，统一执行success;
        Promise.race接受一个包含多个promise对象的数组，只要有一个完成，就执行success
      4、Async/Await简介与用法
        1、Async/Await简介
          async/await是写异步代码的新方式，优于回调函数和Promise。
          async/await是基于Promise实现的，它不能用于普通的回调函数。
          async/await与Promise一样，是非阻塞的。
          async/await使得异步代码看起来像同步代码，再也没有回调函数。但是改变不了JS单线程、异步的本质。
        2、Async/Await的用法
          使用await，函数必须用async标识
          await后面跟的是一个Promise实例
          需要安装babel-polyfill，安装后记得引入 //npm i --save-dev babel-polyfill
          *当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。
      5、Async/Await错误处理
        await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。
        try..catch错误处理也比较符合我们平常编写同步代码时候处理的逻辑。
      6、为什么Async/Await更好
        Async/Await较Promise有诸多好处，以下介绍其中三种优势：
        1. 简洁
          使用Async/Await明显节约了不少代码。我们不需要写.then，不需要写匿名函数处理Promise的resolve值，
          也不需要定义多余的data变量，还避免了嵌套代码。
        2. 中间值
          你很可能遇到过这样的场景，调用promise1，使用promise1返回的结果去调用promise2，然后使用两者的结果去调用promise3
          const makeRequest = () => {
            return promise1()
              .then(value1 => {
                return promise2(value1)
                  .then(value2 => {        
                    return promise3(value1, value2)
                  })
              })
          }
          使用async/await的话，代码会变得异常简单和直观

          const makeRequest = async () => {
            const value1 = await promise1()
            const value2 = await promise2(value1)
            return promise3(value1, value2)
          }
        3、条件语句
          下面示例中，需要获取数据，然后根据返回数据决定是直接返回，还是继续获取更多的数据。
          const makeRequest = () => {
            return getJSON()
              .then(data => {
                if (data.needsAnotherRequest) {
                  return makeAnotherRequest(data)
                    .then(moreData => {
                      console.log(moreData)
                      return moreData
                    })
                } else {
                  console.log(data)
                  return data
                }
              })
          }
          代码嵌套（6层）可读性较差，它们传达的意思只是需要将最终结果传递到最外层的Promise。
          使用async/await编写可以大大地提高可读性:

          const makeRequest = async () => {
            const data = await getJSON()
            if (data.needsAnotherRequest) {
              const moreData = await makeAnotherRequest(data);
              console.log(moreData)
              return moreData
            } else {
              console.log(data)
              return data    
            }
          }

### 10、数组

      数组中许多方法，在次我们简单介绍一下数组的遍历方法，forEach，map，filter，find，every，some，reduce等方法，
      他们都有一个共同的方法，不会改变原来的数组
      1、forEach：遍历数组
        const colors = ['red', 'green', 'blue'];
        colors.forEach((color) => console.log(color));
      2、map：将数组映射成另一个数组
        map通过指定函数处理数组的每个元素，并返回处理新的数组，map不会改变原来的数组
        forEach和map的区别在于，forEach返回没有返回值
        map需要返回值，如果不给return，默认返回undefined
        // es6 map方法
        const doubled = numbers.map(function(number){
           return number * 2;
        })
        console.log(doubled);//[2,4,6]
      3、filter：从数组中找出所有符合指定条件的元素
        filter检测数值元素，并返回符合条件所有元素的数组，filter不会改变原始数组
        // es6 filter
        const porducts = [
          {name:"cucumber",type:"vegetable"},
          {name:"banana",type:"fruit"},
          {name:"celery",type:"vegetable"},
          {name:"orange",type:"fruit"}
        ];
        const filtered2 = porducts.filter(function(product){
          return product.type === "vegetable";
        })
        console.log(filtered2);
        4、find：返回通过测试（函数内判断）的数组的第一个元素的值
          他的参数是一个回调函数，所有数组成员依次执行该回调函数，知道找出第一个返回值为true的成员，然后返回该成员。
          如果没有符合条件的成员，则返回undefined。
          const users = [
            {name:"Jill"},
            {name:"Alex",id:2},
            {name:"Bill"},
            {name:"Alex"}
          ];
          // es6 find
          user = users.find(function(user) {
            return user.name === "Alex";
          });
          console.log(user); // { name:"Alex", id:2 } 找到后就终止循环
        5、every&some
          every：数组中是否每一个元素都满足指定的条件
          some：数组中是否有元素满足指定的条件
          const computers = [
           {name:"Apple",ram:16},
           {name:"IBM",ram:4},
           {name:"Acer",ram:32}
          ];
          //ES6 some every 
          const every = computers.every(function(computer){
             return computer.ram > 16;
          });
          console.log(every);//false
          const some = computers.some(function(computer){
            return computer.ram > 16;
          });
          console.log(some); //true
          ****一言以蔽之，some是一真即为真，every一假即为假
        6、reduce：将数组合成一个值
          reduce的方法接收一个方法作为累加器，数组中的每一值（从左到右）开始合并，最终为一个值
          const numbers = [10,20,30];
          const sumValue = numbers.reduce(function(sum2,number2){
            console.log(sum2);//0 10 30 60
            return sum2 + number2;
          },0); // sum2初始值为0
          console.log(sumValue);

### 11、Proxy

      Proxy是ES6中新增的功能，可以用来自定义对象的操作
      // target：代表需要添加代理的对象
      // handler：用来自定义对象中的操作
      let p = new Proxy(target, handler);
      可以很方便的使用Proxy来实现一个数据绑定和监听
      let onWatch = (obj, setBind, getLogger) => {
        let handler = {
          get(target, property, receiver) {
            getLogger(target, property);
            return Reflect.get(target, property, receiver);
          },
          set(target, property, value, receiver) {
            serBind(value);
            return Reflect.set(target, property, value);
          }
        };
        return new Proxy(obj, handler);
      }; 
      let obj = { a: 1 };
      let value;
      let p = onWatch(obj, (v) => {value = v}, (target, property) => {
          console.log(`Get '${property}' = ${target[property]}`);
      });
      p.a = 2;
      p.a

### 12、正则表达式

      元字符
        元字符
        .      匹配任意字符除了换行符和回车符
        []     匹配方括号内的任意字符。比如[0-9]就可以用来匹配任意数字
        ^      ^9，这样使用代表匹配以9开头，[^9],这样使用代表不匹配方括号内除了9的字符
        {1,2}  匹配1到2位字符
        (yck)  只匹配和yck相同字符串
        |      匹配|前后任意字符
        \      转移
        *      只匹配出现0次及以上*前的字符
        +      只匹配出现1次及以上+前的字符   
        ?      ？之前的字符可选
      修饰语
        i      忽略大小写
        g      全局搜索
        m      多行
      字符简写
        \w     匹配字母数字或者下划线
        \W     和上面相反
        \s     匹配任意的空白符
        \S     和上面相反
        \d     匹配数字
        \D     和上面相反
        \b     匹配单词的开始或结束
        \B     和上面相反

### 13、垃圾回收
  
      1、垃圾回收的必要性
        在c与c++等语言中，开发人员可以直接控制内存的申请和回收。但是在Java、C#、JavaScript语言中，变量的内存空间的申请
        和释放都由程序自己处理，开发人员不需要关心。也就是说JavaScript具有自动垃圾回收机制。
        JS垃圾回收的机制很简单：找出不在使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，
        所以垃圾回收器会按照固定的时间间隔周期性的执行

      2、垃圾回收机制
        垃圾回收有两种方法：标记清除，引用计数。（标记清除是最为常用的方法）
        1、标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量加上标记。然后他会去掉环境中变量以及被环境中的变量引用的标记。
          而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
          最后，垃圾收集器完成内存清除工作，销毁那些带有标记的值，并回收他们所占用的内存空间。
        2、引用计数：引用计数就是在语言引擎中有一张表，保存内存中所有的资源（通常是各种值）的引用册数。如果一个值的引用次数为0，
          就表示这个值不在被用到了，因此可以将这块内存释放。
      最好在不用这些变量的时候将其职位空。
          function func() {
              let obj1 = {};
              let obj2 = {};

              obj1.a = obj2; // obj1 引用 obj2
              obj2.a = obj1; // obj2 引用 obj1
          }
          obj1 = null;
          obj2 = null;

      3、在那些情况下面会造成内存泄漏

          虽然JS有垃圾回收机制，但是如果代码写的不当，会让变量一直处于“进入环境”的状态，无法被回收。

          1、意外的全局变量
            function foo(arg) {
                bar = "this is a hidden global variable";
            }
            bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。

            另一种意外的全局变量可能由 this 创建:

            function foo() {
                this.variable = "potential accidental global";
            }
            // foo 调用自己，this 指向了全局对象（window）
            foo();
            在 JavaScript 文件头部加上 'use strict'，可以避免此类错误发生。启用严格模式解析 JavaScript，
            避免意外的全局变量

          2、被遗忘的计时器或者回调函数
            这样的代码很常见，如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，
            定时器外面的someResource也不会被释放

          3、闭包
            闭包可以维持函数内局部变量，使其得不到释放。上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调引用外部函数，形成了闭包。
            解决之道，将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用

          4、没有清除的DOM元素的引用
            有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。
            此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除

      4、内存泄漏的识别方法
          步骤:（打开Chrome浏览器）
          1、打开开发者工具 Performance
          2、勾选 Screenshots 和 memory
          3、左上角小圆点开始录制(record)
          4、停止录制
          5、图中 Heap 对应的部分就可以看到内存在周期性的回落也可以看到垃圾回收的周期,如果垃圾回收之后的最低值(我们称为min),
             min在不断上涨,那么肯定是有较为严重的内存泄漏问题

          避免内存泄漏的一些方式：
          1、减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收
          2、注意程序逻辑，避免“死循环”之类的
          3、避免创建过多的对象
          4、总而言之需要遵循一条原则：不用了的东西要及时归还

      5、垃圾回收的使用的场景优化

        1、数组优化
          将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，
          并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，
          并且同时能实现数组重用，减少内存垃圾的产生
          const arr = [1, 2, 3, 4];
          console.log('浪里行舟');
          arr.length = 0  // 可以直接让数字清空，而且数组类型不变。
          arr = []; // 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象

        2、对象尽量复用
          var t = {} // 每次循环都会创建一个新对象
          for (var i = 0; i < 10; i++) {
            // var t = {};// 每次循环都会创建一个新对象
            t.age = 19
            t.name = '123'
            t.index = i
            console.log(t)
          }
          t = null //对象如果已经不用了，那就立即设置为null；等待垃圾回收

        3、在循环中的函数表单时，能复用最好方法放大循环外面      
          // 推荐用法
          function t(a) {
            console.log(a)
          }
          for (var k = 0; k < 10; k++) {
            t(k)
          }
          t = null

### 14、模块化

       开发中最流行的CommonJS，AMD，ES6，CMD等方面

       1、什么是模块
         模块：
          1、将一个复杂的程序依据一定的规则封装成几个块（文件），并组合在一起
          2、块的内部数据和实现都是私有的，只是向外部暴露一些接口与外部其他的模块通信

         模块化的进化过程
          1、全局function模式：将不同的功能封装成不同的全局函数
            编码：将不同的功能封装成不同的全局函数
            问题：污染全局命名空间，容易引起命名冲突或者数据不全，而且模式成员之间看不出直接关系
          2、namespace模式：简单对象封装
            作用：减少了全局变量，解决了命名冲突
            问题：数据不安全（外部可以直接修改模块内部的数据）
          3、IIFE模式（Immediately Invoked Function Expression）：匿名函数自调用（闭包）
            作用：数据是私有的，外部只能通过暴露的方法操作
            编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口
            问题：如果当前这个模块依赖另外一个模块会有问题
          4、IIFE模式增强：引入依赖

         模块化的好处
          1、避免命名冲突（减少命名空间的污染）
          2、更好的分离，按需加载
          3、更高复用性
          4、高可维护性

         引入多个<script>后出现问题
          1、请求过多
             首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多
          2、依赖模糊
             我们不知道他们之间的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错
          3、难以维护
             以上的两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现了严重的问题。模块化固然有多个好处，
             然而一个页面需要引入多个js文件们，就会出现以上这些问题。而这些问题可以通过模块化规范来解决

        2、模块化规范
          CommonJS
            1、概述：Node应用有模块组成，采用CommonJS模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量
               、函数、类，都是私有，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理

            2、特点：
              1、所有代码都运行在模块作用域，不会污染全局作用域
              2、模块可以多次加载，但是只会在第一次加载时运行依次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存
              3、模块加载的顺序，按照其在代码中出现的顺序

            3、基本语法
              1、暴露模块：module.exports = value或exports.xxx = value
              2、引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径
              CommonJS规定的是每一个模块的内部，module变量代表当前模块。这个变量是一个对象，他的exports属性（module.exports）
              是对外的接口。加载某个模块，其实是加载该模块的module.esports属性
                // example.js
                var x = 5;
                var addX = function (value) {
                  return value + x;
                };
                module.exports.x = x;
                module.exports.addX = addX;
                上面代码通过module.exports输出变量x和函数addX。

                //如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
                var example = require('./example.js');
                console.log(example.x); // 5
              require命令用于加载模块文件。require命令的基本功能是，读入并执行一个js文件，然后返回该模块的exports对象。对象没有发现指定模块，会报错

            4、模块的加载机制
              CommonJS模块的加载机制是，输入的是被输出的值得拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值，这点与ES6模块化的有重大差异

          AMD
            CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范是非同步加载模块，允许指定回调函数。由于node.js主要用于服务器端编程，
            模块文件一般都已经处在与本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，
            要从服务器端加载模块，这是就必须采用非同步模式，因此浏览器一般采用AMD规范

          CMD
            CMD规范专门用于浏览器端，模块的加载时异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在Sea.js中，所有的JS模块都遵循CMD模块定义规范

          ES6模块化
            ES6模块化的设计塑像是尽量的静态化，使得编译是就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。
            比如，CommonJS模块就是对象，输入时不需查找对象属性。
             1、ES6模块化的语法
             2、ES6模块与CommonJS模块的差异
               他们有两个重大差异：
               1、CommonJS模块输出的是一个值得拷贝，ES5模块输出值的引用
               2、CommonJS模块是运行时加载，ES6模块是编译时输出接口
               3、ES6模块是动态引用，并不会缓存值，模块里面的变量绑定其所在的模块
             3、ES6-Babel-Browserify使用教程
               使用Babel将ES6编译为ES5代码，使用Browserify编译打包js

          总结：
           1、CommonJS规范只要用于服务器端编程，加载模块是同步的，这并不适合在浏览器端，因为同步意味着阻塞加载，浏览器端的资源是异步加载的，因此才会有AMD和CMD解决方案。
           2、AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMS规范开发成本高，代码的阅读和书写比较困难，模块定义的方式的语义不顺畅
           3、CMD规范与AMD规范很相似，用于浏览器编程，依赖就近，延迟加载，可以很容易在node.js中运行。不过，依赖SPM打包，模块的加载逻辑偏重
           4、ES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案

### 15、事件循环

     1、线程与进程
       我们经常说JS是单线程执行的，指的是一个进程里面只有一个主线程。进程是CPU资源分配的最小单位；线程是CPU调度的最小单位。
       多线程与多进程
        1、多进程：是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，
          比如你可以听歌的同时可以打开编辑器敲代码，两个进程之间互不打扰
        2、多线程：程序中包好了多个执行流，即在一个终须中可以同时运行多个不同的线程来执行不同的任务，
          也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。
          以Chrome为例，在打开一个Tab页面的时，其实就是创建了一个进程，一个进程可以有多个线程，比如说渲染线程，JS引擎线程，
          HTTP请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束的后，该线程可能就会被销毁

     2、浏览器内核
       简单的说浏览器内核就是通过取得页面内容，整理信息（应用CSS），计算和组合最终输出可视化的图像结果，通常也被成为渲染引擎。
       浏览器内核是多线程，在内核控制下的个线程相互配合一保持同步，一个浏览器通常有一下常驻线程组成
         GUI渲染线程
          主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
          当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
          该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染
         JS引擎线程
          该线程当然是主要负责处理 JavaScript脚本，执行代码。
          也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。
          当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。
         定时出发线程
          负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
          主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。
         事件触发线程
          主要负责将准备好的事件交给 JS引擎线程执行。
          比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行
         异步HTTP请求线程
          负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。
          主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行

     3、浏览器中Event Loop
        1、Micro-Task 与 Macro-Task
          浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。
          常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。
          常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。

        2、Event Loop过程解析
          1、一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
          2、全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 
             macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，
             这个过程本质上是队列的 macro-task 的执行和出队的过程。
          3、上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；
             而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
          4、执行渲染操作，更新界面
          5、检查是否存在 Web worker 任务，如果有，则对其进行处理
          6、上述过程循环往复，直到两个队列都清空
          ****结论：
          当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，
          执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推

     4、Node 中的 Event Loop
        Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，
        libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现
          1、Node.js的运行机制如下:
            V8引擎解析JavaScript脚本。
            解析后的代码，调用Node API。
            libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
            V8引擎再将结果返回给用户。
          2、六个阶段
            外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段
            (I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段（按照该顺序反复运行）
              timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
              I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
              idle, prepare 阶段：仅node内部使用
              poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
              check 阶段：执行 setImmediate() 的回调
              close callbacks 阶段：执行 socket 的 close 事件回调
              注意：上面六个阶段都不包括 process.nextTick
          3、Micro-Task与Macro-Task
            node端事件循环的异步队列也是这两种，宏任务和微任务队列。
              常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。
              常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。
          4、注意点
            1、setTimeout 和 setImmediate
              二者非常相似，区别主要在于调用时机不同。
              setImmediate 设计在poll阶段完成时执行，即check阶段；
              setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行
            2、process.nextTick
              这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，
              就会清空队列中的所有回调函数，并且优先于其他 microtask 执行

     5、Node与浏览器的Event Loop差异
        浏览器环境下，microtask的任务队列是每一个macrotask执行完成之后执行。而在node.js中，microtask会在事件循环的各个阶段之间执行，
        也就是一个阶段执行完毕，就会去执行microtask队列的任务
     6、总结
        浏览器和Node环境下，microtask任务队列的执行时机不同
          1、node端，microtask在事件循环的各个阶段之间执行
          2、浏览器端，microtask在事件循环的macrotask执行完成之后执行
          在node更新到11版本之后，event loop运行原理发生了改变，一旦执行一个阶段里面的一个红任务就立刻执行微任务队列，变成和浏览器端一致了

### 16、ES6的核心

      1、开发环境配置
        babel：ES6转换成ES5
        webpack：功能强大的模块打包器
        rollup：没有冗余代码的模块打包器

      2、数组的扩展
        Array.of
        Array.from
          如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”(array-like object),即为伪数组。
          典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。
        find和findIndex
        includes
        entries、keys和values

      3、模板字符串
        可以用来定义多行字符串

      4、结构赋值
        对象：（{ type, name} = node ）、默认值、嵌套对象解构
        数组：默认值、与rest参数搭配、用来赋值上下文，但是需要小括号包裹表达式

      5、展开运算符
        与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，
        并将各个项作为分离的参数传给函数。当用在字符串或数组前面时称为扩展运算符,个人觉得可以理解为rest参数的逆运算，
        用于将数组或字符串进行拆解。有些时候，函数不允许传入数组，
        此时使用展开运算符就很方便，不信的话，咱们看个例子：Math.max()方法，它接受任意数量的参数，并会返回其中的最大值。
          let value1 = 25,        
          let value2 = 50;
          console.log(Math.max(value1, value2));  //  50
        但若想处理数组中的值，此时该如何找到最大值？Math.max()方法并不允许你传入一个数组。其实你可以像使用rest参数那样在该数组
        前添加...,并直接将其传递给 Math.max()
          let values = [25,50,75, 100]
          //等价于console.log(Math.max(25,50,75,100));
          console.log(Math.max(...values)); //100

        扩展运算符还可以与其他参数混用
          let values = [-25,-50,-75,-100]
          console.log(Math.max(...values,0)); //0

        扩展运算符拆解字符串与数组
          var array = [1,2,3,4,5];
          console.log(...array);//1 2 3 4 5
          var str = "String";
          console.log(...str);//S t r i n g

        还可以实现拼接
          var defaultColors = ["red","greed"];
          var favoriteColors = ["orange","yellow"];
          var fallColors = ["fire red","fall orange"];
          console.log(["blue","green",...fallColors,...defaultColors,...favoriteColors]
          //["blue", "green", "fire red", "fall orange", "red", "greed", "orange", "yellow"]

      6、rest参数
        与解构赋值组合使用
        与箭头函数结合
        注意点：rest参数必须是最后一个参数、rest参数不能用于对象字面量setter之中
          let object = {
              set name(...value){   //报错
                  //执行一些逻辑
              }
          }

        ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。
        rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
        也可以与解构赋值组合使用
          var array = [1,2,3,4,5,6];
          var [a,b,...c] = array;
          console.log(a);//1
          console.log(b);//2
          console.log(c);//[3, 4, 5, 6]

        rest 参数还可以与箭头函数结合
          const numbers = (...nums) => nums;
          numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]  
      7、块作用域带来的好处
        不在需要立即执行函数表达式（IIFE）
        循环体中的闭包不在有问题
        防止重复声明变量
      8、class与传统构造函数
        如何实现类：原型链
        如何实现继承：extend
        有何区别：class在语法上面更加忒和面向对象的写法
                 class实现继承更加易读、易理解、对初学者来说更好
                 本质上面还是语法糖，使用的是prototype
      9、promise
         原理：pending、fulfilled、reject
         使用流程：new Promise一个实例，而且要return
                  new Promise时候要传入函数，函数要有resolve和reject
      10、ES6模块化
         import 、export
      11、箭头函数
        缩减代码
        改变this的指向

      12、迭代器
        JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就需要一种统一的接口机制，
        来处理所有不同的数据结构。遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署
        Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
        1、Iterator的作用：
          为各种数据结构，提供一个统一的、简便的访问接口；
          使得数据结构的成员能够按某种次序排列
          ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费
          
        2、原生具备iterator接口的数据(可用for of遍历)
          Array
          set容器
          map容器
          String
          函数的 arguments 对象
          NodeList 对象
            let arr3 = [1, 2, 'kobe', true];
            for(let i of arr3){
               console.log(i); // 1 2 kobe true
            }
            let str = 'abcd';
            for(let item of str){
               console.log(item); // a b c d
            }   
            function fun() {
                for (let i of arguments) {
                   console.log(i) // 1 4 5
                }
            }
            fun(1, 4, 5)
            var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
            for (var e of engines) {
              console.log(e);
            }
            // Gecko
            // Trident
            // Webkit  

        3、迭代器的工作原理
           创建一个指针对象，指向数据结构的起始位置
           第一次调用next方法，指针自动指向数据结构的第一个成员
           接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员
           每调用next方法韩慧的是一个包含value和done的对象，【value，当前成员的值，done：布尔值】
             value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束
             当遍历结束的时候返回的value的值是undefined，done的值是true

        4、手写一个迭代器
            function myIterator(arr) {
              let nextIndex = 0
              return {
                next: function() {
                  return nextIndex < arr.length
                    ? { value: arr[nextIndex++], done: false }
                    : { value: undefined, done: true }
                }
              }
            }
            let arr = [1, 4, 'ads']// 准备一个数据
            let iteratorObj = myIterator(arr)
            console.log(iteratorObj.next()) // 所有的迭代器对象都拥有next()方法，会返回一个结果对象
            console.log(iteratorObj.next())
            console.log(iteratorObj.next())
            console.log(iteratorObj.next())

        5、注意点
          1、for of循环不支持遍历普通对象
              var obj = { a: 2, b: 3 }
                 for (let i of obj) {
                   console.log(i) // Uncaught TypeError: obj is not iterable
              }
             对象的Symbol.iterator属性，指向该对象的默认遍历器方法。当使用for of去遍历某一个数据结构的时候，首先去找Symbol.iterator，
             找到了就去遍历，没有找到的话不能遍历，提示Uncaught TypeError: XXX is not iterable
          2、当使用扩展运算符（...）或者对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法
              let arr1 = [1,3]
              let arr2 = [2,3,4,5]
              arr2 = [1,...arr2,6]
              console.log(arr2) // [1, 2, 3, 4, 5, 6]

      13、生成器
        1、概念
          Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同
          语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态
          Generator函数除了状态机，还是一个遍历器对象生成函数
          可暂停函数，yield可暂停，next方法了启动，每次返回的是yield后的表达式结果

        2、特点
          function关键字与函数名之间有一个星号
          函数体内部使用yield表达式，定义不同的内部状态
            function* generatorExample(){
                console.log("开始执行")
                yield 'hello';  
                yield 'generator'; 
             }
            // generatorExample() 
            // 这种调用方法Generator 函数并不会执行
            let MG = generatorExample() // 返回指针对象
            MG.next() //开始执行  {value: "hello", done: false}
          Generator 函数是分段执行的，调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回
          {value: yield后的表达式结果/undefined, done: false/true},再次调用next方法会从上一次停止时的yield处开始，直到最后。
            function* helloWorldGenerator() {
              yield 'hello';
              yield 'world';
              return 'ending';
            }
            var hw = helloWorldGenerator();
            hw.next()// { value: 'hello', done: false }
            hw.next()// { value: 'world', done: false }
            hw.next()// { value: 'ending', done: true }
            hw.next()// { value: undefined, done: true }

        3、next传递参数
            yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
              function* generatorExample () {
                console.log('开始执行')
                let result = yield 'hello'
                console.log(result)
                yield 'generator'
              }
              let MG = generatorExample()
              MG.next()
              MG.next()
              // 开始执行
              // undefined
              // {value: "generator", done: false}
            没有传值时result默认是undefined，接下来我们向第二个next传递一个参数，看下输出结果
              function* generatorExample () {
                console.log('开始执行')
                let result = yield 'hello'
                console.log(result)
                yield 'generator'
              }
              let MG = generatorExample()
              MG.next()
              MG.next(11)
              // 开始执行
              // 11
              // {value: "generator", done: false}

          4、与iterator接口的关系
              由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使该对象具有iterator接口
                let obj = { username: 'kobe', age: 39 }
                obj[Symbol.iterator] = function* myTest() {
                  yield 1;
                  yield 2;
                  yield 3;
                };
                for (let i of obj) {
                  console.log(i) // 1 2 3
                }
              上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得obj对象具有了 Iterator 接口，可以被for of遍历了

          5、Generator的异步的应用
              业务需求：
                发送ajax请求获取新闻内容
                新闻内容获取成功后再次发送请求，获取对应的新闻评论内容
                新闻内容获取失败则不需要再次发送请求。
              如何实现(前端核心代码如下)：
                function* sendXml() {
                  // url为next传参进来的数据
                 let url = yield getNews('http://localhost:3000/news?newsId=2');//获取新闻内容
                  yield getNews(url);//获取对应的新闻评论内容，只有先获取新闻的数据拼凑成url,才能向后台请求
                }
                function getNews(url) {
                  $.get(url, function (data) {
                    console.log(data);
                    let commentsUrl = data.commentsUrl;
                    let url = 'http://localhost:3000' + commentsUrl;
                    // 当获取新闻内容成功，发送请求获取对应的评论内容
                    // 调用next传参会作为上次暂停是yield的返回值
                    sx.next(url);
                  })
                }
                let sx = sendXml();// 发送请求获取新闻内容
                sx.next();

### 17、CSS

    1、如何居中一个元素
      主要介绍水平居中、垂直居中以及水平垂直居中的各种方法
      1、水平居中
        1、行内元素水平居中
          利用text-align: center可以实现在块级元素内部的行内元素水平居中。此方法对inline，inline-block、
          inline-table和inline-flex元素水平居中有效
          // 在父容器设置
          .parent {
            text-align: center;
          }
          此外，如果块级元素内部包着也是一个块级元素，我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。
            <div class="parent">
              <div class="child">Demo</div>
            </div>
            <style>
              .parent{
                text-align:center;  
              }
              .child {
                display: inline-block;
              }
            </style>
        2、块级元素的水平居中
          1、将该块级元素左右外边距margin-left和margin-right设置为auto
            .child {
                width: 100px; //确保该块级元素定宽
                margin:0 auto;
            }
          2、使用table+margin
            先将子元素设置为块级表格来显示（类似），再将其设置水平居中
            display:table在表现上类似block元素，但是宽度为内容宽。
            <div class="parent">
              <div class="child">Demo</div>
            </div>
            <style>
              .child {
                display: table;
                margin: 0 auto;
              }
            </style>
          3、使用absolute+transform
              先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。

              <div class="parent">
                <div class="child">Demo</div>
              </div>
              <style>
                .child {
                  position:absolute;
                  left:50%;
                  transform:translateX(-50%);
                }
                .parent {
                  position:relative;
                }
              </style>
              不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀。
          4、使用flex+justify-content
              通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。
              <div class="parent">
                <div class="child">Demo</div>
              </div>
              <style>
                .parent {
                  display: flex;
                  justify-content:center;
                }
              </style>
          5、使用flex+margin
              通过flex将父容器设置为为Flex布局，再设置子元素居中。
              <div class="parent">
                <div class="child">Demo</div>
              </div>
              <style>
                .parent {
                  display: flex;
                }
                .child {
                  margin:0 auto;
                }
              </style>
        3、多块级元素水平居中
          1、利用flex布局
             利用弹性布局(flex)，实现水平居中，其中justify-content 用于设置弹性盒子元素在主轴（默认横轴）方向上的对齐方式，本例中设置子元素水平居中显示。
               #container {
                  display: flex;
                  justify-content: center;
               }
          2、利用inline-block
              将要水平排列的块状元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。
              .container {
                text-align: center;
              }
              .inline-block {
                display: inline-block;
              }
        4、浮动元素水平居中
          对于定宽的浮动元素，通过子元素设置relative + 负margin
          对于不定宽的浮动元素，浮动元素都用相对定位
          通用方法（不管定宽还是不定宽）：flex布局
          1、定宽的非浮动元素
             通过子元素设置relative + 负margin
             .child {
                 position:relative;
                 left:50%;
                 margin-left:-250px;
              }
              <div class="parent">
                <span class="child" style="float: left;width: 500px;">我是要居中的浮动元素</span>
              </div>
          2、不定宽的浮动元素
              注意：要清除浮动，给外部元素加上float。这里的父元素就是外部元素
              <div class="box">
                  <p>我是浮动的</p>
                  <p>我也是居中的</p>
              </div>
              .box{
                  float:left;
                  position:relative;
                  left:50%;
              }
              p{
                  float:left;
                  position:relative;
                  right:50%;
              }
          3、通用办法flex布局(不管是定宽还是不定宽)
             利用弹性布局(flex)的justify-content属性，实现水平居中
             .parent {
                  display:flex;
                  justify-content:center;
              }
              .chlid{
                  float: left;
                  width: 200px;//有无宽度不影响居中
              }
              <div class="parent">
                <span class="chlid">我是要居中的浮动元素</span>
              </div>
        5、绝对定位元素水平居中
            这种方式非常独特，通过子元素绝对定位，外加margin: 0 auto来实现。
              <div class="parent">
                  <div class="child">让绝对定位的元素水平居中对齐。</div>
              </div>
              .parent{
                 position:relative;
              }
              .child{
                 position: absolute; /*绝对定位*/
                 width: 200px;
                 height:100px;
                 background: yellow;
                 margin: 0 auto; /*水平居中*/
                 left: 0; /*此处不能省略，且为0*/
                 right: 0;/*此处不能省略，且为0*/
              }
      2、垂直居中
         1、单行内联元素垂直居中
            <div id="box">
                 <span>单行内联元素垂直居中。</span>。
            </div>
            <style>
             #box {
                height: 120px;
                line-height: 120px;
                border: 2px dashed #f69c55;
                }
            </style>
         2、多行内联元素垂直居中
            1、利用flex布局
              利用flex布局实现垂直居中，其中flex-direction: column定义主轴方向为纵向。这种方式在较老的浏览器存在兼容性问题。
                <div class="parent">
                    <p>Dance like nobody is watching, code like everybody is.    
                    Dance like nobody is watching, code like everybody is.    
                    Dance like nobody is watching, code like everybody is.</p>
                </div>
                <style>
                    .parent { 
                        height: 140px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        border: 2px dashed #f69c55;
                    }
                </style>
            2、利用表布局（table）
               利用表布局的vertical-align：middle可以实现子元素垂直居中
                 <div class="parent">
                    <p class="child">The more technology you learn, the more you realize how little you know.
                    The more technology you learn, the more you realize how little you know.
                    The more technology you learn, the more you realize how little you know.</p>
                </div>
                 <style>
                    .parent {
                        display: table;
                        height: 140px;
                        border: 2px dashed #f69c55;
                    }
                    .child {
                        display: table-cell;
                        vertical-align: middle;
                    }
                </style>
            3、块级元素垂直居中
              1、使用absolute + 负margin（已知高度宽度）
                通过绝对定位元素距离顶部50%。并设置margin-投票向上偏移高度的一半，就可以实现了
                  <div class="parent">
                      <div class="child">固定高度的块级元素垂直居中。</div>
                  </div>
                  .parent {
                    position: relative;
                  }
                  .child {
                    position: absolute;
                    top: 50%;
                    height: 100px;
                    margin-top: -50px;
                  }
              2、使用absolute+transform
                  当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题。
                    <div class="parent">
                        <div class="child">未知高度的块级元素垂直居中。</div>
                    </div>
                    .parent {
                      position: relative;
                    }
                    .child {
                      position: absolute;
                      top: 50%;
                      transform: translateY(-50%);
                    }
              3、使用flex+align-items
                  通过设置flex布局中的属性align-items，使子元素垂直居中。
                  <div class="parent">
                      <div class="child">未知高度的块级元素垂直居中。</div>
                  </div>
                  .parent {
                      display:flex;
                      align-items:center;
                  }
              4、使用table-cell+vertical-align
                  通过将父元素转化为一个表格单元格显示（类似 <td> 和 <th>），再通过设置 vertical-align属性，使表格单元格内容垂直居中。
                  <div class="parent">
                    <div class="child">Demo</div>
                  </div>
                  <style>
                    .parent {
                      display: table-cell;
                      vertical-align: middle;
                    }
                  </style>
      3、水平垂直居中
        1、绝对定位与负边距实现（已知高度宽度）
          这种实现方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器
            // css部分
             #container {
                  position: relative;
                }
             #center {
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  margin: -50px 0 0 -50px;
                }
            // html部分(这部分不做变化,下面例子直接共用)
              <body>
                <div id='container'>
                  <div id='center' style="width: 100px;height: 100px;background-color: #666">center</div>
                </div>
              </body>
          2、绝对定位于margin:auto（已知高度和宽度）
            这种方式无需知道被垂直居中元素的高和宽，但是不能兼容低版本的IE浏览器
               #container {
                    position: relative;
                    height:100px;//必须有个高度
               }
               #center {
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    margin: auto;//注意此处的写法
               }
          3、绝对定位+CSS3（位置元素的高度）
             利用CSS3的transform，可以轻松的在位置元素的高度的情况下实现元素的垂直居中。CSS3的transform固然好用，
             但是在项目中必须考虑兼容问题，大量的hack代码可能会导致得不偿失
               #container {
                  position: relative;
               }
               #center {
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%, -50%);
               }
          4、flex布局
             利用flex布局，其中justify-content用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；
             而align-items属性定义flex子项在flex容器的当前行的测轴（纵轴）方向上的对齐方式，不能兼容IE浏览器
                #container {//直接在父容器设置即可
                  height: 100vh;//必须有高度
                  display: flex;
                  justify-content: center;
                  align-items: center;
                }
          5、flex/grid与margin:auto（最简单的写法）
              容器元素设为 flex 布局或是grid布局，子元素只要写 margin: auto 即可,不能兼容低版本的IE浏览器。
                #container {
                  height: 100vh;//必须有高度
                  display: grid;
                }
                #center {
                  margin: auto;
                }
          备注：
            px：绝对单位，页面的像素
            em：相对单位，基准点为父节点字体的大小，em是指字体高度 浏览器默认1em=16px
            rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性
            vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%
            vh：viewpoint height，视窗高度，1vh等于视窗高度的1%
            vmin：vw和vh中较小的那个
            vmax：vw和vh中较大的那个
            结论：之所以前端行业做移动端会普遍默认用rem或em,是因为可以通过js控制根元素(或者用@media)来达到适配各种分辨率的字体大小的效果

    2、关于相应式布局
      移动前端中常说的 viewport （视口）就是浏览器中用于呈现网页的区域。视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下。手机端与
       PC 端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的;
       iOS, Android 基本都将这个视口分辨率设置为 980px
      1、为什么手机端视口要设为 980px
        如何用小屏幕访问大屏幕的页面也同样可读呢？乔帮主就想着为手机固定一个视口宽度，让手机的视口宽度等于世界上绝大多数 PC
        网页的版心宽度，就是 980px。这样，用手机访问电脑版网页的时候，旁边刚好没有留白。不过页面缩放后文字会变得非常小，
        用户需要手动放大缩小才能看清楚，体验非常差
      2、约束视口
        为了解决前面的问题，可以在网页的中添加下面这行代码：
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
          width=device-width   视口为设备宽度（就是人设置的一个宽度）//不设置的话默认为980px
          initial-scale=1.0    初始化的视口大小是1.0倍
          maximum-scale=1.0    最大的倍数是1.0倍
          user-scalable=0      不允许缩放视口
        这个视口的尺寸，是手机厂商设置的，能够保证我们的文字比如 16px，在自己的这个视口下清晰、大小刚刚合适。所以
        大屏幕的手机的约束视口 > 小屏幕手机的约束视口。这就能够保证我们的网页可以用 px 写字号、写行高。
        需要注意的是：约束之后的视口宽度，不是自己的分辨率！！每个手机的分辨率，都要比自己的视口宽度大得多得多！
        最最重要的一句话：前端开发工程师，丝毫不关心手机的分辨率，我们只关心视口
        
      3、图片
        可以用 CSS 给图片指定固定宽度，但问题是我们想让它能在不同大小的屏幕中自动缩放。比如，我们例子中的 iPhone 屏幕宽度为 320 像素，
        如果我们把图片设置成 320 像素宽，那么 iPhone 屏幕旋转后又怎么办呢？这时候 320 像素变成了 480 像素
        解决方案很简单，只要一行 CSS 代码就可以让图片随容器宽度自动缩放:
          .img {
            max-width: 100%;
          }
        这里声明 max-width 规则，就是要保证所有图片最大显示为其自身的 100%（即最大只可以显示为自身那么大）。此时，
        如果包含图片的元素（比如包含图片的 body 或 div）比图片固有宽度小，图片会缩放占满最大可用空间。

        为什么不用 width:100%?
        要实现图片的自动缩放，也可以使用更通用的 width 属性，比如 width:100%。然而，这条规则在这里并不适用。因为
        这条规则会导致它显示得跟它的容器一样宽。在容器比图片宽得多的情况下，图片会被无谓地拉伸
      4、手机浏览器内核
        在移动端，仅有四个独立的浏览器内核，分别为微软的 Trident、火狐的 Gecko、开源内核 Webkit、Opera 的 Presto。
        目前微软的 Trident 在移动终端上主要为 WP7、8 系统内置浏览器。Opera 的 Presto 内核主要为 Opera Mobile、OperaMini、
        欧朋浏览器以及欧朋 HD Beta 版。Webkit 内核的适用范围则较为广泛，Android 原理：pending、fulfilled、reject生浏览器、
        苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。
          兼容的前缀：
            1 -ms-
            2 -moz-
            3 -o-
            4 -webkit-
          UC、Android 内置、Chrome、Safari、QQ Browser 都是 webkit 内核，从图上看占了绝大部分的市场份额。
          所以一定要伺候好-webkit-。 有的公司干脆只兼容-webkit-，别的兼容比如-ms-都不写
      5、流失布局
        百分比布局也叫作流式布局、弹性盒布局。手机网页没有版心，都左右撑满
        百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的
        如果用百分比写 width，那么指的是父元素 width 的百分之多少
        如果用百分比写 height，那么指的是父元素 height 的百分之多少
        如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding
        如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。
        不能用百分比写 border 的宽度
      6、媒体查询
         1、为什么响应式 Web 设计需要媒体查询
         CSS3 媒体查询可以让我们针对特定的设备能力或条件为网页应用特定的 CSS 样式。如果没有媒体查询，光用 CSS 
         是无法大大修改网页外观的。这个模块让我们可以提前编写出适应很多不可预测因素的 CSS 规则，比如屏幕方向水平或垂直、
         视口或大或小等等。弹性布局虽然可以让设计适应较多场景，也包括某些尺寸的屏幕，但有时候确实不够用，
         因为我们还需要对布局进行更细致的调整。媒体查询让这一切成为可能，它就相当于 CSS 中基本的条件逻辑

         2、媒体查询语法
         我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、
         不同能力的设备，渐进增加不同的视觉效果和功能
          body {
            background-color: grey;
          }
          @media screen and (min-width:1200px){
            body {
              background-color: pink;
            }
          }
          @media screen and (min-width:700px) and (max-width:1200px){
            body {
              background-color: blue;
            }
          }
          @media screen and (max-width:700px){
            body {
              background-color: orange;
            }
          }
          其中@media 就表示媒体查询，查询现在看这个网页的设备是什么，以及它的宽度是多少。screen 表示看这个网页的设备是显示器，
          而不是残疾人听力设备、也不是打印机。后面用 and 符号罗列所有的可能性。
          值得注意：媒体查询只能包裹选择器，不能包裹 k:v 对儿。

          IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面

      7、rem相应布局
          rem 响应式布局思想
            一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值
            高度值可以设置固定值,设计稿有多大,我们就严格写多大
            所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值)
            JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了  

          什么是 rem,它与 em 有何区别
            rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的
            em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)
            em 为单位的时候，font-size 属性是计算后继承，box1 计算出来是 40px。那么里面的 box2继承的是 40px。em
             单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如width、height、padding、margin、border

          运用场景
            如果我们做的 H5 页面只在移动端访问，这是因为 REM 不兼容低版本的浏览器。而如果移动端和 PC 端公用一套代码，建议使用流式布局

          如何做个 REM 响应式布局

            1、从 UI 设计师拿到 PSD 设计稿,然后在样式中给 HTML 设定一个 font-size 的值，我们一般都设置一个方便后面计算的值，例如：100px
              html {
                font-size:100px;//1rem=100px
              }

            2、写页面，写样式
              首先按照设计稿的尺寸来写样式，然后在写样式值的时候，需要把得到的像素值除以 100 计算出对应的 REM 的值。
              值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局
                margin: 0  0.2rem;
                height: 3rem;

            3、根据当前屏幕的宽度和设计稿的宽度来计算我们 HTML 的 font-size 的值
                例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个 font-size 的值为
                 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其 font-size 应该设置为多少。

                375/640*100->fontsize=58.59375//此时轮播图能自适应手机屏幕大小
                根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的 fontsize 值应该是多少，如果 fontsize 的值改变了，
                之前设定的所有 REM 单位的值自动会跟着放大或者缩小。可以通过以下这段代码实现：
                  <script>
                    ~function(){
                    var desW=640,
                    winW=document.documentElement.clientwidth,
                    ratio=winW/desW;
                    document.documentElement.style.fontSize=ratio*100+"px";
                    }();
                  </script>
                但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：
                  // html部分
                  <section id="main">
                    <div class="box"></div>
                  </section>
                  // js部分
                  <script>
                    ~function(){
                    var desW=640,
                    winW=document.documentElement.clientwidth,
                    ratio=winW/desW;
                    var oMain=document.getElementById(main")；
                    if(winW>desW){
                    oMain.style.width=desW+"px";
                    oMain.style.margin="0 auto";
                    return;
                    }
                    document.documentElement.style.fontSize=ratio*100+"px";
                    }();
                  </script>

    3、深入理解BFC

       1、 Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，
       它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 
       Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。Block formatting context
       直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，
       并且与这个区域外部毫不相干。通俗地讲，BFC是一个容器，用于管理块级元素

       2、如何创建BFC
          float为left和right
          overflow为hidden、auto、scroll
          display为table-cell、table-caption、inline-block、inline-flex、flex
          position为absolute、fixed
          根元素

       3、BFC布局规则
          内部的box会在垂直方向，一个接一个的防止（即块级元素独占一行）
          BFC的区域不会再与float box重叠（利用这一点可以实现自适应两栏布局）
          内部的box垂直方向的距离由margin决定，属于同一个BFC的两个相邻的Box的margin会发生重叠（margin重叠三个条件；同属于一个BFC；相邻；块级元素）
          计算BFC的高度时，浮动元素也参与计算（清除浮动haslayout）
          BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此
          
       4、BFC的特征
          1、BFC会阻止垂直外边距折叠
            按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠，这个包括相邻元素或者嵌套元素，
            只要他们之间没有阻挡（比如边框、非空内容、padding等）就会发生margin重叠。
            1、相邻兄弟元素margin重叠问题
            2、父子元素margin重叠问题
          2、BFC不会重叠浮动元素
            利用这个特性，我们可以创造自适应两栏布局
          3、BFC可以包含浮动----清除浮动
            我们都知道浮动会脱离文档流，由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），
            未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden

    4、如何清除浮动
       W3school中给出的浮动定义为浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止，
       由于浮动框脱离文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样
        1、特点
         主要是脱标、贴边、字围和收缩
         一个浮动的内联元素（比如span img标签）不需要设置display：block就可以设置宽度。
         <style>
                div{
                    float: left;
                    background-color: greenyellow;
                }
            </style>
         </head>
         <body>
         <div>
            这是一段文字
         </div>
         </body>
         我们都知道div标签是块级元素，会独占一行，然而上面的例子中将div设置为左浮后，其宽度不再是占满一行，
         而是收紧为内部元素的宽度，这就是浮动第四个特征的含义

        2、缺点
          这就是浮动带来副作用----父容器高度塌陷，于是清理浮动就显着至关重要

        3、清理浮动

          清除浮动不是不用浮动，清除浮动产生的父容器高度塌陷
          1、给浮动元素的父元素添加高度（扩展性不好）
            如果一个元素要浮动，那么它的父元素一定要有高度。高度的盒子，才能关住浮动。可以通过直接给父元素设置height，
            实际应用中我们不大可能给所有的盒子加高度，不仅麻烦，并且不能适应页面的快速变化；另外一种，
            父容器的高度可以通过内容撑开（比如img图片），实际当中此方法用的比较多

          2、clear:both;
            在最后一个子元素新添加最后一个冗余元素，然后将其设置clear:both,这样就可以清除浮动。这里强调一点，
            即在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度。
              <div id="wrap">
                  <div id="inner"></div>
                  <div style="clear: both;"></div>
              </div>
              #wrap{
                    border: 1px solid;
              }
              #inner{
                    float: left;
                    width: 200px;
                    height: 200px;
                    background: pink;
              }

          3、伪元素清除浮动
            结合:after伪元素和IEhack，可以完美兼容当前主流的各大浏览器，这里的IEhack指的是出发hasLayout
              <div id="wrap" class="clearfix">
                  <div id="inner"></div>
              </div>
              #wrap {
                border: 1px solid;
              }
              #inner {
                float: left;
                width: 200px;
                height: 200px;
                background: pink;
              }
              /*开启haslayout*/
              .clearfix {
                *zoom: 1;
              }
              /*ie6 7 不支持伪元素*/
              .clearfix:after {
                content: '';
                display: block;
                clear: both;
                height:0;
                line-height:0;
                visibility:hidden;//允许浏览器渲染它，但是不显示出来
              }
            给浮动元素的父容器添加一个clearfix的class，然后给这个class添加一个:after伪元素，
            实现元素末尾添加一个看不见的块元素来清理浮动。这是通用的清理浮动方案，推荐使用

          4、给父元素使用overflow:hidden;
             这种方案让父容器形成了BFC（块级格式上下文），而BFC可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。
             BFC的触发方式
              我们可以给父元素添加以下属性来触发BFC：
                float 为 left | right
                overflow 为 hidden | auto | scorll
                display 为 table-cell | table-caption | inline-block
                position 为 absolute | fixed
                这里可以给父元素设置overflow:auto，但是为了兼容IE最好使用overflow:hidden
                但这种办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉，所以这时候不能使用
             BFC的主要特征:
               BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题
               BFC不会重叠浮动元素
               BFC可以包含浮动,这可以清除浮动

          5、br标签清浮动
             br标签存在一个属性：clear。这个属性就是能够清除浮动的利器，在br标签中设置属性clear，并赋值all。即能清除掉浮动
              <div id="wrap">
                <div id="inner"></div>
                <br clear="all" />
              </div>
                #wrap {
                  border: 1px solid;
                }
                #inner {
                  float: left;
                  width: 200px;
                  height: 200px;
                  background: pink;
                }

    5、Less即学即用
       为了解决CSS的这一困境，CSS预处理预编译的思想脱颖而出，比较具有代表性的有LESS、SASS、Stylus。它们在传统的CSS基础上
       增加了大量的新的语法，编写方式，常用的函数等，可以让我们的CSS像JS一样成为一门编程语言。本文主要介绍LESS的语法和使用

       1、LESS的编译

        1、在浏览·器中调用LESS.JS
          LESS只支持在现代浏览器中运行（最新版本的Chrome, Firefox, Safari 和 IE）。我们不建议在生产环境中使用LESS客户端，
          因为在将LESS编译成CSS的时候，用户会看到加载延迟的现象，即便在浏览器中有不足一秒的加载延迟，但也会降低性能。

          首先引入我们设置样式的LESS文件，注意：这里的rel='stylesheet/less'

          <link type="text/css" rel="stylesheet/less" href="1.less"/>
          然后引入less.js文件

          <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/3.8.1/less.min.js" ></script>
          浏览器中调用有个好处:可以开启监视模式,只要我们的LESS改变，在一定时间内，浏览器就会重新的编译，我们可以看到想要的效果。具体操作如下:

          <script charset="utf-8" type="text/javascript">
            // -> 在引入LESS之前设置一个全局的变量less,配置一些参数值(根据情况自行选择需要配置的项)
            var less = {
              //->env:设置运行的环境(生产模式还是开发模式)
              //production:编译后的CSS缓存到本地localStorage中
              //development:没有把编译后的CSS缓存到本地,在URL不是标准的格式下(例如:file://...),自动设置为development
              env: "development",
              //->poll:在监视模式下，每两次请求之间的时间间隔(ms)
              poll:500
              }
          </script>     
          <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/3.8.1/less.min.js" ></script>
          <script charset="utf-8" type="text/javascript">
            //->启用监视模式(env必须要设置成development)
            less.watch();
          </script>   

        2、使用NODE命令编译LESS(单个文件)
          这种方式是目前项目中最常用的方式，适用于项目的生产环境，它是把我们的LESS文件编译成CSS文件，我们项目中直接的引入CSS文件即可，
          基本步骤：安装->编译/压缩编译->或者使用NODE代码实现批量编译等

        3、在NODE环境中编写批量编译的代码
          我们在上述用NODE命令编译的时候，一次只能编译一个文件，这样，如果页面中有多个LESS，每一次编译都是比较耗费时间的，
          所以我们结合NODE的FS文件读写操作，可以写一套批量编译的代码

        4、目前常用的编译工具有：Koala(据说目前最流行的)、在线编译

       2、LESS的语法
         LESS的基础语法基本上分为以下几个方面：变量、混合(Mixins)、嵌套规则、运算、函数、作用域等
         1、变量
            和JS中的变量一样，只是LESS的变量定义不是使用VAR而是使用@。

              //->LESS代码
                @link-color: #428bca;
                @link-color-hover: darken(@link-color, 10%);
                a {
                    color: @link-color;
                    &:hover {
                        color: @link-color-hover;
                    }
                }
              //->编译为CSS的结果
                a {
                    color: #428bca;
                }
                a:hover {
                    color: #3071a9;
                }
            除了上述用变量存储公用的属性值，我们还可以用变量存储公用的URL、选择器等等

                //->LESS代码
                .@{selector} {
                    width: 100px;
                    height: 100px;
                    @{property}: #000;
                    background: url("@{bgImg}/test.png");
                }
                @selector: box;
                @bgImg: "../img";
                @property: color;

         2、混合(Mixins)
            1、基本使用
                混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A
                中的所有属性。我们还可以带参数地调用，就像使用函数一样
                    //->LESS代码
                    .public {
                        width: 100px;
                        height: 100px;
                    }
                    nav ul {
                        .public;
                        list-style: none;
                    }
                    //->编译为CSS的结果
                    .public {
                        width: 100px;
                        height: 100px;
                    }
                    nav ul {
                        width: 100px;
                        height: 100px;
                        list-style: none;
                    }
                上述的代码，nav ul是把public中设定的样式属性值copy了一份到自己的样式中。如果你想在编译完成
                的结果中不输出public这个样式的结果，只需要按照下述的代码编写即可：

                    //->LESS代码
                    .public() {//->在选择器后面加上()就可以不编译这个样式了
                        width: 100px;
                        height: 100px;
                    }
                    nav ul {
                        .public;//如果public有子孙元素的样式，同样也会被复制过来
                        list-style: none;
                    }
                    //->编译为CSS的结果
                    nav ul {
                        width: 100px;
                        height: 100px;
                        list-style: none;
                    }

            2、extend
                虽然在上述的案例中，nav ul把public中的样式继承了过来，但是原理却是把代码copy一份过来，
                这样编译后的CSS中依然会存留大量的冗余CSS代码，为了避免这一点，我们可以使用extend伪类来实现
                样式的继承使用。和原来的选择器共用一套样式，但要保证原来的选择器不加括号。

                    //->LESS代码
                    .public {
                        width: 100px;
                        height: 100px;
                    }
                    nav ul {
                        &:extend(.public);
                        list-style: none;
                    }
                    //->编译为CSS的结果
                    .public, nav ul {
                        width: 100px;
                        height: 100px;
                    }
                    nav ul {
                        list-style: none;
                    }

         3、嵌套规则
            我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰
            //->LESS代码
            #header {
              color: black;
              .navigation {
                font-size: 12px;
              }
              .logo {
                width: 300px;
                &:hover { text-decoration: none }
              }
            }
            //->编译为CSS的结果
            #header { color: black; }
            #header .navigation {
              font-size: 12px;
            }
            #header .logo { 
              width: 300px; 
            }
            #header .logo:hover {
              text-decoration: none;
            }

         4、函数 & 运算
            运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的
            复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值

            任何数字、颜色或者变量都可以参与运算. 来看一组例子:

            @base: 5%;
            @filler: @base * 2;
            @other: @base + @filler;
            color: #888 / 4;
            background-color: @base-color + #111;
            height: 100% / 2 + @filler;
            LESS 提供了一系列的颜色运算函数. 颜色会先被转化成 HSL 色彩空间, 然后在通道级别操作:

            lighten(@color, 10%);     // return a color which is 10% *lighter* than @color
            darken(@color, 10%);      // return a color which is 10% *darker* than @color
            LESS提供了一组方便的数学函数，你可以使用它们处理一些数字类型的值:

            round(1.67); // returns `2`
            ceil(2.4);   // returns `3`
            floor(2.6);  // returns `2`
         5、命名空间和作用域
            LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。

            @var: red;
            #page {
              @var: white;
              #header {
                color: @var; // white
              }
            }
            #footer {
              color: @var; // red  
            }

    6、几种常见的CSS布局
      1、单列布局
       常见的单列布局有两种：
        header,content和footer等宽的单列布局
        header与footer等宽,content略窄的单列布局
        1、如何实现

          对于第一种，先通过对header,content,footer统一设置width：1000px;或者max-width：
          1000px(这两者的区别是当屏幕小于1000px时，前者会出现滚动条，后者则不会，显示出实际宽度);
          然后设置margin:auto实现居中即可得到

          对于第二种，header、footer的内容宽度不设置，块级元素充满整个屏幕，
          但header、content和footer的内容区设置同一个width，并通过margin:auto实现居中

      2、两列自适应布局
        两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式

        1、float+overflow:hidden
          如果是普通的两列布局，浮动+普通元素的margin便可以实现，但如果是自适应的两列布局，
          利用float+overflow:hidden便可以实现，这种办法主要通过overflow触发BFC，而BFC不会重叠浮动元素。由于
          设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。具体代码如下：
            <div class="parent" style="background-color: lightgrey;">
                <div class="left" style="background-color: lightblue;">
                    <p>left</p>
                </div>
                <div class="right"  style="background-color: lightgreen;">
                    <p>right</p>
                    <p>right</p>
                </div>        
            </div>
            .parent {
              overflow: hidden;
              zoom: 1;
            }
            .left {
              float: left;
              margin-right: 20px;
            }
            .right {
              overflow: hidden;
              zoom: 1;
            }

        2、flex布局
           Flex布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局
           // html部分同上
            .parent {
              display:flex;
            }  
            .right {
              margin-left:20px; 
              flex:1;
            }

        3、grid布局
           Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计
            //html部分同上
            .parent {
              display:grid;
              grid-template-columns:auto 1fr;
              grid-gap:20px
            } 

## 二、浏览器

### 1、事件机制
    事件触发三阶段
      1、window往事件触发处传播，遇到注册的捕获事件会触发
      2、传播到事件触发处时触发注册的事件
      3、从事件触发处往window传播，遇到注册的冒泡事件触发
      事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，
      事件触发会按照注册的顺序执行
          // 以下会先打印冒泡然后是捕获
          node.addEventListener(
            'click',
            event => {
              console.log('冒泡')
            },
            false
          )
          node.addEventListener(
            'click',
            event => {
              console.log('捕获 ')
            },
            true
          )

    注册事件
      通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于
      布尔值 useCapture 参数来说，该参数默认值为false。useCapture决定了注册的事件是捕获事件还是
      冒泡事件。对于对象参数来说，可以使用以下几个属性
        1、capture，布尔值，和 useCapture 作用一样
        2、once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听
        3、passive，布尔值，表示永远不会调用 preventDefault

      一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的
      进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止
      捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件
          node.addEventListener(
            'click',
            event => {
              event.stopImmediatePropagation()
              console.log('冒泡')
            },
            false
          )
          // 点击 node 只会执行上面的函数，该函数不会执行
          node.addEventListener(
            'click',
            event => {
              console.log('捕获 ')
            },
            true
          )
    事件代理
      如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上
          <ul id="ul">
            <li>1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
            <li>5</li>
          </ul>
          <script>
            let ul = document.querySelector('##ul')
            ul.addEventListener('click', event => {
              console.log(event.target)
            })
          </script>
      事件代理的方式相对于直接给目标注册事件来说，有以下优点
        节省内存
        不需要给子节点注销事件

### 2、跨域
    因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，
    Ajax 请求会失败。我们可以通过以下几种常用方法解决跨域的问题

      1、JSONP
        JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。通过 <script> 
        标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时
          <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
          <script>
              function jsonp(data) {
                console.log(data)
            }
          </script>
        JSONP 使用简单且兼容性不错，但是只限于 get 请求，在开发中可能会遇到多个 JSONP 
        请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现
          function jsonp(url, jsonpCallback, success) {
            let script = document.createElement('script')
            script.src = url
            script.async = true
            script.type = 'text/javascript'
            window[jsonpCallback] = function(data) {
              success && success(data)
            }
            document.body.appendChild(script)
          }
          jsonp('http://xxx', 'callback', function(value) {
            console.log(value)
          })

      2、CORS
          CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 
          CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 
          Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，
          如果设置通配符则表示所有网站都可以访问资源

      3、document.domain
          该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式
          只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域

      4、postMessage
          这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
          // 发送消息端
          window.parent.postMessage('message', 'http://test.com')
          // 接收消息端
          var mc = new MessageChannel()
          mc.addEventListener('message', event => {
            var origin = event.origin || event.originalEvent.origin
            if (origin === 'http://test.com') {
              console.log('验证通过')
            }
          })

### 3、存储
      sessionStorage，localStorage，cookie
      同：都是保存在浏览器端，且都遵循同源策略
      异：在于生命周期和作用域的不同
      作用域：localStorage只要在相同的协议、主机名。端口下，就能读取到同一份的localStorage的数据。
             sessionStorage在localStorage的基础上还要在同一个窗口下面
      生命周期：localStorage除非手动删除，否则是永远不过期
               sessionStorage只是临时存储，他是会话级别的存储，当回话结束，存储的内容也随之被释放
               cookie：在设置时间之后（服务器端设置的），浏览器端设置的是关闭页面就失效的 

### 4、渲染机制
      1、浏览器的渲染机制一般分为以下几个步骤
          1、处理 HTML 并构建 DOM 树
          2、处理 CSS 构建 CSSOM 树
          3、将 DOM 与 CSSOM 合并成一个渲染树
          4、根据渲染树来布局，计算每个节点的位置
          5、调用 GPU 绘制，合成图层，显示在屏幕上
         在构建CSSOM树时，会阻塞渲染，直至CSSOM树构建完成，并且构建CSSOM树是一个十分消耗性能的过程。所以要尽量保证层级扁平，
         减少过度重叠，越是具体的CSS选择器，执行速度越慢。当HTML解析到script的标签的时候，会暂停构建DOM，
         完成后才会从暂停的地方重新开始，也就是说，如果你想首屏的加载速度，渲染速度越快，就不应该在首屏的位置加载JS文件。并且
         CSS文件也会影响JS的执行，只有当解析完样式表才会执行JS，所以也可以认为在这种情况下，CSS也会暂停构建DOM

      2、Load 和 DOMContentLoaded 区别
          Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕
          DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载

      3、图层
        一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，
        所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用
        通过以下几个常用属性可以生成新图层
          3D 变换：translate3d、translateZ
          will-change
          video、iframe 标签
          通过动画实现的 opacity 动画转换
          position: fixed

      4、重绘（Repaint）和回流（Reflow）
          重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大
          重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
          回流是布局或者几何属性需要改变就称为回流
          回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流
          所以以下几个动作可能会导致性能问题：
              改变 window 大小
              改变字体
              添加或删除样式
              文字改变
              定位或者浮动
              盒模型
          很多人不知道的是，重绘和回流其实和 Event loop 有关
            1、当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 
               的刷新率，每 16ms 才会更新一次
            2、然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 
              16ms 才会触发一次，并且自带节流功能
            3、判断是否触发了 media query
            4、更新动画并且发送事件
            5、判断是否有全屏操作事件
            6、执行 requestAnimationFrame 回调
            7、执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
            8、更新界面
            9、以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调

## 三、性能

### 1、页面优化的方法
    1、资源的压缩和合并
      主要包括这些方面：html压缩、css 压缩、js的压缩和混乱和文件合并
      资源压缩可以从文件中去掉多余的字符，比如回车、空格。你在编辑器中写代码的时候，会使用缩进和注释，
      这些方法无疑会让你的代码简洁而且易读，但它们也会在文档中添加多余的字节

      压缩合并css和js可以减少网站http请求的次数，但合并文件可能会带来问题:首屏渲染和缓存失效问题。那该如何
      处理这问题呢？----公共库合并和不同页面的合并
      如何进行文件合并
      使用在线网站进行文件合并
      使用nodejs实现文件合并(gulp、fis3)

    2、非核心的代码异步加载
      异步加载的三种方式——async和defer、动态脚本创建

    3、利用浏览器的缓存机制
      强缓存：不会向服务器发送请求，直接从缓存中读取数据
        相关的header:(espires，Cache-Control)
        简单概括：其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，
        两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥
        用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于
        是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新
        的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略
      协商缓存：
        向服务器发送请求，服务器会根据这个请求的request，header的一些参数来判断是否命中协商缓存，如果命中，
        则返回304状态码并带上新的response，header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用
        相关的header:(Last-Modified、If-Modified-Since)
           第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端
        两者之间对比：
          首先在精确度上，ETag是要优先于Last-Modified的。Last-Modified的时间单位是秒，如果某个文件在1秒
          内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡
          的服务器，各个服务器生成的Last-Modified也有可能不一致
          第二在性能上，Etag要逊于Last-Modified。，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值
          第三在优先级上，服务器校验优先考虑Etag
        缓存的机制
          强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存
          (Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，
          那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存
        用户行为对浏览器缓存的影响
          地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制
          F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断
          ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉去资源

    4、使用CDN（内容分发网络）
        大型的Web对速度的追求并没有停止利用浏览器的缓存，因为浏览器的缓存只是为了提高第二次访问的速度，对于第一次的访问速度，
        我们需要从网络层次进行优化，最为常见的手段就是CDN加速。通过将静态资源缓存到离用户很近的的相同网络运营商的CDN节点上，
        不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负担
       CDN是怎么做到加速的呢
        其实这是CDN服务商在全国各个省份部署计算节点，CDN加速将网站的内容缓存在网络边缘,不同地区的用户就会访问到离自己最近的
        相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，
        从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来
        以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益

    5、预解析DNS

        资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到
        通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成
         DNS 解析。例如，我们将来可从 example.com 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容：
          <link rel="dns-prefetch" href="//example.com">

        当我们从该 URL 请求一个资源时，就不再需要等待DNS的解析过程。该技术对使用第三方资源特别有用。通过简单的一行代码就可以
        告知那些兼容的浏览器进行 DNS 预解析，这意味着当浏览器真正请求该域中的某个资源时，DNS 的解析就已经完成了,从而节省了宝贵的时间
        另外需要注意的是，浏览器会对a标签的href自动启用DNS Prefetching，所以a标签里包含的域名不需要在head中手动设置link。
        但是在HTTPS下不起作用，需要meta来强制开启功能。这个限制的原因是防止窃听者根据DNS Prefetching推断显示在HTTPS页面中超链接的主机名。
        下面这句话作用是强制打开a标签域名解析
          <meta http-equiv="x-dns-prefetch-control" content="on">
  
### 2、懒加载和预加载

    1、懒加载

      1、懒加载也是延迟加载，指的是在长网页面中延迟加载图像，是一种很好优化网页邢恩能够的方式。用户滚动到他们之间，
      可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，他还可以邦之
      减少服务器负载。常使用图片很多，页面很长的电商网站场景中

      2、为什么要使用懒加载
        1、提升用户体验
        2、减少无效资源的加载，减少服务器的压力
        3、防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用

      3、懒加载的原理
        首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去
        监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 
        属性设置为data-original 的值，这样就可以实现延迟加载
        
      4、懒加载的实现步骤
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Lazyload</title>
                <style>
                  .image-item {
                  display: block;
                  margin-bottom: 50px;
                  height: 200px;//一定记得设置图片高度
              }
                </style>
            </head>
            <body>
            <img src="" class="image-item" lazyload="true"  data-original="images/1.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/2.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/3.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/4.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/5.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/6.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/7.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/8.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/9.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/10.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/11.png"/>
            <img src="" class="image-item" lazyload="true"  data-original="images/12.png"/>
            <script>
                var viewHeight =document.documentElement.clientHeight//获取可视区高度
                function lazyload(){
                  var eles=document.querySelectorAll（'img[data-original][lazyload]'）
                  Array.prototype.forEach.call(eles,function(item,index){
                  var rect
                  if(item.dataset.original==="")
                     return
                  rect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
                  if(rect.bottom>=0 && rect.top < viewHeight){
                    !function(){
                      var img=new Image()
                      img.src=item.dataset.original
                      img.onload=function(){
                        item.src=img.src
                        }
                    item.removeAttribute（"data-original"）//移除属性，下次不再遍历
                    item.removeAttribute（"lazyload"）
                       }()
                    }
                   })
                }
                lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片
                document.addEventListener（"scroll"，lazyload)
            </script>
            </body>
            </html>

    2、预加载
       1、资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说
       就是将所有所需的资源提前加载到本地，这样后面在需要用到的时候就可以直接从缓存中取到资源
       2、预加载的使用是为了提升用户体验，减少等待时间
       3、预加载的几种使用方法
         1、使用HTML的标签
           <img src="" style="display:none"/>
         2、使用Image对象
            <script src="./myPreload.js"></script>
            // myPreload.js文件
            var image = new Image()
            image.src=""
         3、使用XMLHttpRequest对象,虽然存在跨域问题，但会精细控制预加载过程
         4、使用PreloadJS库

    3、两者之间的对比
       两者都是提高页面性能有效的方法，一个是提前加载，一个是延迟甚至是不加载。懒加载对于前端的体验有一定的缓解压力，预加载则会增加服务器前端压力

### 3、其他

     1、使用 Webpack 优化项目
        1、对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
        2、使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
        3、优化图片，对于小图可以使用 base64 的方式写入文件中
        4、按照路由拆分代码，实现按需加载
        5、给打包出来的文件名添加哈希，实现浏览器缓存文件

     2、监控
        1、对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外
         1、对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性
         2、对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归
        2、对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch
        但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug
        对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求

     3、面试题
        如何渲染几万条数据并不卡主界面
        这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，
        那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次

## 四、安全

### 1、XSS
    XSS 分为三种：反射型，存储型和 DOM-based
    最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义
    内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和
    数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段

### 2、CSRF
    跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，
    通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[1]
    跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任

    简单点说，CSRF 就是利用用户的登录态发起恶意请求
    防范 CSRF 可以遵循以下几种规则：
        Get 请求不对数据进行修改
        不让第三方网站访问到用户 Cookie
        阻止第三方网站请求接口
        请求时附带验证信息，比如验证码或者 token

### 3、密码安全

    通常需要对密码加盐，然后进行几次不同加密算法的加密

## 五、框架通识

### 1、MVVM

### 2、路由原理

### 3、Virtual DOM

### 4、diff算法

## 六、Vue

### 1、NextTick原理

### 2、生命周期

### 3、VueRouter的源码解析

## 七、React	

### 1、生命周期

### 2、setState

### 3、redux的源码解析

### 4、UmiJS的解析
    细节请参考 https://umijs.org/zh/guide/
    umi，中文发音乌米，是一个可插拔的企业级react应用框架，具有以下的优势：
      1、开箱即用，内置 react、react-router 等
      2、类 next.js 且功能完备的路由约定，同时支持配置的路由方式
      3、完善的插件体系，覆盖从源码到构建产物的每个生命周期
      4、一键兼容到 IE9
      5、完善的 TypeScript 支持
      6、与 dva 数据流的深入融合

    在开发到一定阶段，会遇到一些问题:
      1、项目做大的时候，开发调试的启动和热更新的时间会变得更长
      2、大项目下面，网站打开的很慢，没有基于路由做到按需加载
      3、dva的model每次都要手写载入，能否在一开始就通项目初始化好


### 5、DvaJS的解析
    细节请参考 https://dvajs.com/guide/
    dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架；dva 是体验技术部开发的 React 应用框架，将上面三个 React 工具库包装在一起，简化了 API，让开发 React 应用更加方便和快捷
      dva = React-Router + Redux + Redux-saga
    
    特点：
      1、易学易用，仅有 6 个 api（use,start,model等），对 redux 用户尤其友好，配合 umi 使用后更是降低为 0 API
      2、elm 概念，通过 reducers, effects 和 subscriptions 组织 model
      3、插件机制，比如 dva-loading 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading
      4、支持 HMR，基于 babel-plugin-dva-hmr 实现 components、routes 和 models 的 HMR（热替换）

    在 src/index.js 里，dva 一共做了这么几件事：
      1、从 'dva' 依赖中引入 dva ：import dva from 'dva';
      2、通过函数生成一个 app 对象：const app = dva();
      3、加载插件：app.use({});
      4、注入 model：app.model(require('./models/example'));
      5、添加路由：app.router(require('./routes/indexAnother'));
      6、启动：app.start('#root');
      在这 6 步当中，dva 完成了 使用 React 解决 view 层、redux 管理 model、saga 解决异步的主要功能。事实上在我查阅资料以及回忆用过的脚手架时，发现目前端框架之所以被称为“框架”也就是解决了这些事情。前端工程师至今所做的事情都是在 分离动态的 data 和静态的 view ，只不过侧重点和实现方式也不同。至今为止出了这么多框架，但是前端 MVX 的思想一直都没有改变

    model方法
      1、checkModel 主要是用 invariant 对传入的 model 进行了合法性检查
      2、refixNamespace 又使用 reduce 对每一个 model 做处理，为 model 的 reducers 和 effects 中的方法添加了 ${namespace}/ 的前缀

    start方法
      start 方法是 dva-core 的核心，在 start 方法里，dva 完成了 store 初始化 以及 redux-saga 的调用
      

### 6、Webpack的解析

# 计算机通识:

## 一、网络

### 1、UDP

     1、面向报文
      UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。
      具体来说：
        1、在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
        2、在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

     2、不可靠性
        1、UDP 是无连接的，也就是说通信不需要建立和断开连接。
        2、UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
        3、UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是
          在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP

     3、高效
        因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP
        的至少二十字节要少得多，在传输数据报文时是很高效的

        头部包含了以下几个数据：
        1、两个十六位的端口号，分别为源端口（可选字段）和目标端口
        2、整个数据报文的长度
        3、整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误
     4、传输方式
        UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

### 2、TCP

     1、头部
        对于 TCP 头部来说，以下几个字段是很重要的
        1、Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
        2、Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
        3、Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制
        4、标识符
          URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定
                 位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
          ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
          PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
          RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
          SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
          FIN=1：该字段为一表示此报文段是一个释放连接的请求报文

     2、状态机
        HTTP 是无连接的，所以作为下层的TCP协议也是无连接的，虽然看似TCP将两端连接了起来，但是其实只是两端共同维护了一个状态。TCP 
        是全双工的，在断开连接时两端都需要发送FIN和ACK，在TCP协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管
        是客户端还是服务端，TCP连接建立完后都能发送和接收数据，所以TCP也是一个全双工的协议。起初，两端都为CLOSED状态。在通信开始前，
        双方都会创建TCB。服务器创建完TCB后遍进入LISTEN状态，此时开始等待客户端发送数据

### 3、HTTP

    1、GET与POST的区别
      GET在浏览器回退时是无害的，而POST会再次提交请求
      GET请求会被浏览器主动缓存，而POST不会，除非手动设置
      GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
      GET请求在URL中传送的参数是有长度限制的，而POST没有限制
      GET参数通过URL传递，POST放在Request body中
      
      状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
        1xx：指示信息--表示请求已接收，继续处理
        2xx：成功--表示请求已被成功接收、理解、接受
        3xx：重定向--要完成请求必须进行更进一步的操作
        4xx：客户端错误--请求有语法错误或请求无法实现
        5xx：服务器端错误--服务器未能实现合法的请求
      比如我们平时常见两种出错的状态码：
        403 Forbidden                 //对被请求页面的访问被禁止
        404 Not Found                 //请求资源不存在，比如：输入了错误的URL

    2、持久化连接
       1、为什么需要持久连接
          HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。以当年的通信情况来说，因为都是些容量很小的文本传输，
          所以即使这样也没有多大问题。可随着 HTTP 的 普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的
          HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请 求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 
          TCP 连接建立和断开，增加通信量的 开销
       2、持久连接的特点
          为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 
          HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态

          持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，
          使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。在 HTTP/1.1 中，所有的连接默认都是持久连接，
          但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非 标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，
          除了服务器端，客户端也需 要支持持久连接

    3、管道化
       持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能 发送下一个请求。管线化技术出现后，
       不用等待响应亦可直接发送下一个请求，这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。通俗地讲，
       请求打包一次传输过去，响应打包一次传递回来。管线化的前提是在持久连接下

       假如当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。 而管线化技术则比持久连接还要快。请求数越多，
       时间差就越明显。客户端需要请求这十个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求，以此类推，
       而管道机制则是允许浏览器同时发出这十个请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求
       
       于是在使用持久连接的情况下，某个连接上消息的传递类似于
       请求1->响应1->请求2->响应2->请求3->响应3
       管线化方式发送变成了类似这样：
       请求1->请求2->请求3->响应1->响应2->响应3

### 4、HTTPS

     1、HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏 感的通讯，例如交易支付方面。
      HTTPS主要作用是：
      （1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
      （2）对网站服务器进行真实身份认证。
      我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用http://，而是改用https://。另外，
      当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变

     2、反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:
      数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
      数据完整性：内容传输经过完整性校验
      身份认证：第三方无法伪造服务端（客户端）身份

      HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
      关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少
        HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
        HTTPS需要用到SSL证书，而HTTP不用;
        HTTPS标准端口443，HTTP标准端口80;
        HTTPS基于传输层，HTTP基于应用层;
        HTTPS在浏览器显示绿色安全锁，HTTP没有显示;

### 5、HTTP2.0/HTTP3.0

    1、HTTP/1.1的缺陷
       高延迟--带来页面加载速度的降低
       无状态特性--带来的巨大HTTP头部
       明文传输--带来的不安全性
       不支持服务器推送消息
    2、HTTP/2 新特性
       二进制传输
       Header压缩
       多路复用
       Server Push
       提高安全性
    3、总结
       HTTP/1.1有两个主要的缺点：安全不足和性能不高。
       HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；
       QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议

### 6、DNS

      DNS 的作用就是通过域名查询到具体的 IP。

      因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，
      DNS 就是去查询这个别名的真正名称是什么。

      在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 www.google.com 时，会进行一下操作：

      操作系统会首先在本地缓存中查询
      没有的话会去系统配置的 DNS 服务器中查询
      如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
      然后去该服务器查询 google 这个二级域名
      接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
      以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。

      PS：DNS 是基于 UDP 做的查询。

### 7、Web实时推送技术的总结

    1、双向通信
      HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 
      协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。在WebSocket协议之前，
      有三种实现双向通信的方式：轮询（polling）、长轮询（long-polling）和iframe流（streaming）

      1、轮询（polling）
        轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点也很明显：连接数会很多，一个接受，一个发送。而且每次发送请求
        都会有Http的Header，会很耗流量，也会消耗CPU的利用率
          优点：实现简单，无需做过多的更改
          缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担

      2、长轮询（long-polling）
        长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，看有没有新消息，如果没有新消息，就一直等待。当有新消息的时候，才会返回给客户端。
        在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少
        （有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费
          优点：比 Polling 做了优化，有较好的时效性
          缺点：保持连接会消耗资源; 服务器没有返回有效数据，程序超时

      3、iframe流（streaming）
        iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据
        （通常是HTML，内有负责插入信息的javascript），来实时更新页面
          优点：消息能够实时到达；浏览器兼容好
          缺点：服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转

    2、WebSocket
       1、
         WebSocket是一种全新的协议，随着HTML5草案的不断完善，越来越多的现代浏览器开始全面支持WebSocket技术了，它将TCP的Socket（套接字）
         应用在了webpage上，从而使通信双方建立起一个保持在活动状态连接通道

         一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、
         HTML或图片等任意格式的数据。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，
         任意一方都可直接向对方发送报文

       2、HTTP的局限性
         1、HTTP是半双工协议，也就是说，在同一时刻数据只能单向流动，客户端向服务器发送请求(单向的)，然后服务器响应请求(单向的)
         2、服务器不能主动推送数据给浏览器。这就会导致一些高级功能难以实现，诸如聊天室场景就没法实现

       3、WebSocket的特点
         1、支持双向通信，实时性更强
         2、可以发送文本，也可以发送二进制数据
         3、减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，
            通信量也相应减少了；相对于传统的HTTP每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接的通讯模式，
            一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。
            在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，
            实时性优势明显

    3、Web 实时推送技术的比较               
        轮询Polling 
          类型：client→server：
          技术实现：客户端循环请求 
          优点：1、实现简单 2、 支持跨域  
          缺点：1、浪费带宽和服务器资源 2、 一次请求信息大半是无用（完整http头信息） 3、有延迟 4、大部分无效请求 
          适用场景：适于小型应用

        长轮询Long-Polling 
          类型：client→server 
          技术实现：服务器hold住连接，一直到有数据或者超时才返回，减少重复请求次数 
          优点：1、实现简单 2、不会频繁发请求 3、节省流量 4、延迟低 
          缺点：1、服务器hold住连接，会消耗资源 2、一次请求信息大半是无用  
          适用场景：WebQQ、Hi网页版、Facebook IM

        长连接iframe 
          类型：client→server 
          技术实现：在页面里嵌入一个隐蔵iframe，将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。  
          优点：1、数据实时送达 2、不发无用请求，一次链接，多次“推送” 
          缺点：1、服务器增加开销 2、无法准确知道连接状态 3、IE、chrome等一直会处于loading状态 
          适用场景：Gmail聊天

        WebSocket 
          类型：server⇌client 
          技术实现：new WebSocket() 
          优点：1、支持双向通信，实时性更强 2、可发送二进制文件3、减少通信量  
          缺点：1、浏览器支持程度不一致 2、不支持断开重连  
          适用场景：网络游戏、银行交互和支付

        综上所述：Websocket协议不仅解决了HTTP协议中服务端的被动性，即通信只能由客户端发起，也解决了数据同步有延迟的问题，同时还带来了明显的性能优势，
        所以websocket是Web 实时推送技术的比较理想的方案，但如果要兼容低版本浏览器，可以考虑用轮询来实现。

### 8、从输入URL到页面加载完成的过程

     这是一个很经典的面试题，在这题中可以将本文讲得内容都串联起来。

     1、首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来
     2、接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，
        并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
     3、TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据
     4、数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件
     5、首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，
        避免过多次的重定向，超过次数也会报错
     6、浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
     7、文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，
        会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，
        就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率
     8、初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
     9、CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
     10、在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了

## 二、数据结构

### 1、栈

### 2、队列

### 3、链表

### 4、树

### 5、trie

### 6、并查集

### 7、堆

## 三、算法

### 1、时间复杂度

### 2、位运算

### 3、排序

### 4、链表

### 5、树

### 6、动态规划

### 7、字符串相关

## 四、Git

### 1、Git是什么，它与Github什么关系

     Git是一款免费、开源的分布式源代码管理工具
     Github是用Git做版本控制的代码托管平台

### 2、Git常用命令

     一般来说，Git命令日常使用只要记住上图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令
      接下来归纳了一些常用的命令：
      把普通目录变为git工作区
      $ git init
      添加当前目录的所有文件到暂存区
      $ git add .
      提交暂存区到仓库区
      $ git commit -m “XXX”
      恢复暂存区的指定文件到工作区
      $ git checkout [file]
      checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。
      上传本地指定分支到远程仓库（master分支）
      $ git push origin master
      取回远程仓库的变化，并与本地分支合并
      $ git pull [remote] [branch]
      列出所有本地分支
      $ git branch
      新建一个分支，但依然停留在当前分支
      $ git branch [branch-name]//比如git branch dev创建“dev"分支
      新建一个分支，并切换到该分支
      $ git checkout -b [branch] //比如git checkout -b dev切换到“dev"分支
      合并指定分支到当前分支
      $ git merge [branch]

### 3、如何进行多人协作（分支创建与合并）

      为了不受其他开发人员的影响，您可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。常常
      适用于当前开发的项目新增功能时，代码还未写完或者出现bug未调试好，这时创建分支将有效提高工作效率。因为每一次提交的历史
      记录都会在创建分支保存，所以当发生问题时，定位和修改造成问题的提交就容易多了

### 4、Hexo+Github搭建自己个人博客

      Hexo 是一个基于 Node.js 的快速、简洁且高效的博客框架，可以方便的生成静态网页托管在github和Heroku上。Hexo 因其界面简洁、
      美观且对各类人群（不只是程序猿）友好而广受欢迎，声望不亚于大名鼎鼎的WordPress。
      它有以下几个特点：
        超快速度----Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染
        一键部署----只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站
        支持 Markdown----Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件
        丰富的插件----Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript

